// Code generated by scale-signature-go {{ .version }}, DO NOT EDIT.
// schema: {{ .schema.Name }}:{{ .schema.Tag }}
// output: {{ .package }}

package {{ .package }}

import (
	"errors"
	"sync/atomic"
	"sync"
  "github.com/loopholelabs/polyglot"

  "github.com/loopholelabs/scale/extension"
)

const identifier = "{{ .schema.Name }}:{{ .schema.Tag }}"

// Write an error to the scale function guest buffer.
func hostError(mem extension.ModuleMemory, resize extension.Resizer, err error) {
	b := polyglot.NewBuffer()
	polyglot.Encoder(b).Error(err)

	writeBuffer, err := resize("ext_HttpFetch_Resize", uint64(b.Len()))

	if err != nil {
		panic(err)
	}

	if !mem.Write(uint32(writeBuffer), b.Bytes()) {
		panic(err)
	}
}

{{ $schema := .schema }}

type hostExt struct {
  functions map[string]extension.InstallableFunc
  host *{{ .schema.Name }}Host
}

func (he *hostExt) Init() map[string]extension.InstallableFunc {
  return he.functions
}

func (he *hostExt) Reset() {
  // Reset any instances that have been created.
  {{ range $ifc := .schema.Interfaces }}
    he.host.instances_{{ $ifc.Name }} = make(map[uint64]{{ $ifc.Name }})
  {{ end }}
}

func New(impl {{ .schema.Name }}Ifc) extension.HostExtension {
  hostWrapper := &{{ .schema.Name }}Host{ impl: impl }

  fns := make(map[string]extension.InstallableFunc)

// Add global functions to the runtime
{{ range $fn := .schema.Functions }}
  fns["ext_{{ $schema.Name }}_{{ $fn.Name }}"] = hostWrapper.host_ext_{{ $schema.Name }}_{{ $fn.Name }}
{{ end }}

{{ range $ifc := .schema.Interfaces }}
	hostWrapper.instances_{{ $ifc.Name }} = make(map[uint64]{{ $ifc.Name }})

  {{ range $fn := $ifc.Functions }}

  fns["ext_{{ $schema.Name }}_{{ $ifc.Name }}_{{ $fn.Name }}"] = hostWrapper.host_ext_{{ $schema.Name }}_{{ $ifc.Name }}_{{ $fn.Name }}

  {{ end }}
{{ end }}

  return &hostExt{
    functions: fns,
    host: hostWrapper,
  }
}

type {{ .schema.Name }}Host struct {
  impl {{ .schema.Name }}Ifc
{{ range $ifc := .schema.Interfaces }}

  gid_{{ $ifc.Name }} uint64
  instancesLock_{{ $ifc.Name }} sync.Mutex
  instances_{{ $ifc.Name }} map[uint64]{{ $ifc.Name }}

{{ end }}

}

// Global functions
{{ range $fn := .schema.Functions }}

func (h *{{ $schema.Name }}Host) host_ext_{{ $schema.Name }}_{{ $fn.Name}}(mem extension.ModuleMemory, resize extension.Resizer, params []uint64) {
	ptr := uint32(params[0])
	length := uint32(params[1])
	data, _ := mem.Read(ptr, length)

	cd := &{{ $fn.Params }}{}
	cd, err := Decode{{ $fn.Params }}(cd, data)
	if err != nil {
		hostError(mem, resize, err)
	}

  // Call the implementation
	r, err := h.impl.{{ $fn.Name }}(cd)
	if err!=nil {
		hostError(mem, resize, err)
	}

{{- if (IsInterface $schema $fn.Return) }}

	id := atomic.AddUint64(&h.gid_{{ $fn.Return }}, 1)
	h.instancesLock_{{ $fn.Return }}.Lock()
	h.instances_{{ $fn.Return }}[id] = r
	h.instancesLock_{{ $fn.Return }}.Unlock()

	// Return the ID
	params[0] = id

{{ else }}

	b := polyglot.NewBuffer()
	r.Encode(b)

	writeBuffer, err := resize("ext_{{ $schema.Name }}_Resize", uint64(b.Len()))

	if err != nil {
		hostError(mem, resize, err)
	}

	if !mem.Write(uint32(writeBuffer), b.Bytes()) {
		hostError(mem, resize, err)
	}

{{ end }}
}

{{ end }}


{{ range $ifc := .schema.Interfaces }}

{{ range $fn := $ifc.Functions }}

func (h *{{ $schema.Name }}Host) host_ext_{{ $schema.Name }}_{{ $ifc.Name }}_{{ $fn.Name }}(mem extension.ModuleMemory, resize extension.Resizer, params []uint64) {
	h.instancesLock_{{ $ifc.Name }}.Lock()
  r, ok := h.instances_{{ $ifc.Name }}[params[0]]
	h.instancesLock_{{ $ifc.Name }}.Unlock()
	if !ok {
		hostError(mem, resize, errors.New("Instance ID not found!"))
	}

	ptr := uint32(params[1])
	length := uint32(params[2])
	data, _ := mem.Read(ptr, length)

	cd := &{{ $fn.Params }}{}
	cd, err := Decode{{ $fn.Params }}(cd, data)
	if err != nil {
		hostError(mem, resize, err)
	}

	resp, err := r.{{ $fn.Name }}(cd)
	if err != nil {
		hostError(mem, resize, err)
	}


{{- if (IsInterface $schema $fn.Return) }}

	id := atomic.AddUint64(&h.gid_{{ $fn.Return }}, 1)
	h.instancesLock_{{ $fn.Return }}.Lock()
	h.instances_{{ $fn.Return }}[id] = resp
	h.instancesLock_{{ $fn.Return }}.Unlock()

	// Return the ID
	params[0] = id

{{ else }}

	b := polyglot.NewBuffer()
	resp.Encode(b)

	writeBuffer, err := resize("ext_{{ $schema.Name }}_Resize", uint64(b.Len()))

	if err != nil {
		hostError(mem, resize, err)
	}

	if !mem.Write(uint32(writeBuffer), b.Bytes()) {
		hostError(mem, resize, err)
	}

{{ end }}
}

  {{ end }}
{{ end }}
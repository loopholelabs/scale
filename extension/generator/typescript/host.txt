// Code generated by scale-extension 0.4.5, DO NOT EDIT.
// output: v0.1.0

/* eslint no-bitwise: off */

import { Extension as ExtensionInterface, ModuleMemory, Resizer } from "@loopholelabs/scale-extension-interfaces";
import { Decoder, Encoder, Kind } from "@loopholelabs/polyglot";
import * as types from "./types";

export * from "./types";

const hash = "fetch";

// Write an error to the scale function guest buffer.
function hostError(mem: ModuleMemory, resize: Resizer, err: Error) {
  const enc = new Encoder();
  enc.error(err);
  const ptr = resize("ext_fetch_Resize", enc.bytes.length);

  mem.Write(ptr, enc.bytes);
}

class hostExt {
  functions: Map<string, InstallableFunc>;
  host: HttpFetchHost;

  constructor(fns: Map<string, InstallableFunc>, h: HttpFetchHost) {
    this.functions = fns;
    this.host = h;
  }

  Init(): Map<string, InstallableFunc> {
    return this.functions;
  }

  Reset() {
    // Reset any instances that have been created.
    this.host.instances_HttpConnector = new Map<number, HttpConnector();
  }
}

export function New(impl: HttpFetchIfc): ExtensionInterface {
  let hostWrapper = new HttpFetchHost(impl);

  let fns = new Map<string, InstallableFunc>();

  // Add global functions to the runtime

  fns.set("ext_fetch_New", hostWrapper.host_ext_HttpFetch_New.bind(hostWrapper));

  hostWrapper.instances_HttpConnector = new Map<number, HttpConnector>();

  fns.set("ext_fetch_HttpConnector_Fetch", hostWrapper.host_ext_HttpFetch_HttpConnector_Fetch.bind(hostWrapper));

  return new hostExt(fns, hostWrapper);
}

class HttpFetchHost {
  impl: HttpFetchIfc

  gid_HttpConnector: bigint = 0n;
  instances_HttpConnector: Map<bigint, HttpConnector> = new Map<bigint, HttpConnector>();

  constructor(i: HttpFetchIfc) {
    this.impl = i;
  }

  // Global functions...

  host_ext_HttpFetch_New(mem: ModuleMemory, resize: Resizer, params: number[]) {
    console.log("Called host_ext_HttpFetch_New");
    const d = mem.Read(params[1], params[2]);
    const c = types.HttpConfig.decode(new Decoder(d));
    const r = this.impl.New(c);
    const id = this.gid_HttpConnector++;
    this.instances_HttpConnector.set(id, r);
    params[0] = id;
    return;
  }

  // Instance functions...

  host_ext_HttpFetch_HttpConnector_Fetch(mem: ModuleMemory, resize: Resizer, params: number[]): bigint {
    console.log("Called host_ext_HttpFetch_HttpConnector_Fetch", params[0]);
    const d = mem.Read(params[1], params[2]);
    const c = types.ConnectionDetails.decode(new Decoder(d));
    // Do lookup...
    const inst = this.instances_HttpConnector.get(params[0]);
    const r = inst.Fetch(c);
    const enc = new Encoder();
    r.encode(enc);
    const ptr = resize("ext_fetch_Resize", enc.bytes.length);
    mem.Write(ptr, enc.bytes);
    return;
  }

}

//// //// //// //// //// //// //// //// ////

// Interface to the extension impl. This is what the implementor should create

export interface HttpFetchIfc {
  New(params: HttpConfig): HttpConnector;

}

export interface HttpConnector {
  Fetch(params: ConnectionDetails): HttpResponse;

}


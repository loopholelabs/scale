// Code generated by scale-extension {{ .generator_version }}, DO NOT EDIT.
// output: {{ .package_name }}

{{ $schema := .extension_schema }}
{{ $hash := .extension_hash }}

/* eslint no-bitwise: off */

import { Extension as ExtensionInterface, ModuleMemory, Resizer } from "@loopholelabs/scale-extension-interfaces";
import { Decoder, Encoder, Kind } from "@loopholelabs/polyglot";
import * as types from "./types";

export * from "./types";

const hash = "{{ .extension_hash }}";


// Write an error to the scale function guest buffer.
function hostError(mem: ModuleMemory, resize: Resizer, err: Error) {
    const enc = new Encoder();
    enc.error(err);
    const ptr = resize("ext_{{ $hash }}_Resize", enc.bytes.length);

    mem.Write(ptr, enc.bytes);
}

class hostExt {
  functions: Map<string, InstallableFunc>;
  host: {{ .extension_schema.Name }}Host;

  constructor(fns: Map<string, InstallableFunc>, h: {{ .extension_schema.Name }}Host) {
    this.functions = fns;
    this.host = h;
  }

  Init(): Map<string, InstallableFunc> {
    return this.functions;
  }

  Reset() {
    // Reset any instances that have been created.
  {{ range $ifc := .extension_schema.Interfaces }}
    this.host.instances_{{ $ifc.Name }} = new Map<number, {{ $ifc.Name }}();
  {{ end }}
  }
}

export function New(impl: {{ .extension_schema.Name }}Ifc): ExtensionInterface {
  let hostWrapper = new {{ .extension_schema.Name }}Host(impl);

  let fns = new Map<string, InstallableFunc>();

// Add global functions to the runtime
{{ range $fn := .extension_schema.Functions }}
  fns.set("ext_{{ $hash }}_{{ $fn.Name }}", hostWrapper.host_ext_{{ $schema.Name }}_{{ $fn.Name }}.bind(hostWrapper));
{{ end }}

{{ range $ifc := .extension_schema.Interfaces }}
	hostWrapper.instances_{{ $ifc.Name }} = new Map<number, {{ $ifc.Name }}>();

  {{ range $fn := $ifc.Functions }}

  fns.set("ext_{{ $hash }}_{{ $ifc.Name }}_{{ $fn.Name }}", hostWrapper.host_ext_{{ $schema.Name }}_{{ $ifc.Name }}_{{ $fn.Name }}.bind(hostWrapper));

  {{ end }}
{{ end }}

  return new hostExt(fns, hostWrapper);
}

class {{ .extension_schema.Name }}Host {
  impl: {{ .extension_schema.Name }}Ifc

{{ range $ifc := .extension_schema.Interfaces }}
  gid_{{ $ifc.Name }}: bigint = 0n;
  instances_{{ $ifc.Name }}: Map<bigint, {{ $ifc.Name }}> = new Map<bigint, {{ $ifc.Name }}>();
{{ end }}

  constructor(i: {{ .extension_schema.Name }}Ifc) {
    this.impl = i;
  }

  // Global functions...
  {{ range $fn := .extension_schema.Functions }}

  host_ext_{{ $schema.Name }}_{{ $fn.Name}}(mem: ModuleMemory, resize: Resizer, params: number[]) {
    console.log("Called host_ext_{{ $schema.Name }}_{{ $fn.Name}}");

    const d = mem.Read(params[1], params[2]);
    const c = types.{{ $fn.Params }}.decode(new Decoder(d));
    const r = this.impl.{{ $fn.Name }}(c);

    {{- if (IsInterface $schema $fn.Return) }}
      const id = this.gid_{{ $fn.Return }}++;
      this.instances_{{ $fn.Return }}.set(id, r); 
      params[0] = id;
      return;
    {{ else }}
      const enc = new Encoder();
      r.encode(enc);
      const ptr = resize("ext_{{ $hash }}_Resize", enc.bytes.length);
      mem.Write(ptr, enc.bytes);
      return;
    {{ end }}
  }

  {{ end }}

  // Instance functions...
{{ range $ifc := .extension_schema.Interfaces }}

{{ range $fn := $ifc.Functions }}

  host_ext_{{ $schema.Name }}_{{ $ifc.Name }}_{{ $fn.Name }}(mem: ModuleMemory, resize: Resizer, params: number[]): bigint {
    console.log("Called host_ext_{{ $schema.Name }}_{{ $ifc.Name }}_{{ $fn.Name}}", params[0]);

    const d = mem.Read(params[1], params[2]);
    const c = types.{{ $fn.Params }}.decode(new Decoder(d));

    // Do lookup...
    const inst = this.instances_{{ $ifc.Name }}.get(params[0]);

    const r = inst.{{ $fn.Name }}(c);

    {{- if (IsInterface $schema $fn.Return) }}
      const id = this.gid_{{ $fn.Return }}++;
      this.instances_{{ $fn.Return }}.set(id, r); 
      params[0] = id;
      return;
    {{ else }}
      const enc = new Encoder();
      r.encode(enc);
      const ptr = resize("ext_{{ $hash }}_Resize", enc.bytes.length);
      mem.Write(ptr, enc.bytes);
      return;
    {{ end }}
  }
{{ end }}
{{ end }}

}


//// //// //// //// //// //// //// //// ////

// Interface to the extension impl. This is what the implementor should create

export interface {{ .extension_schema.Name }}Ifc {
{{ range $fn := .extension_schema.Functions }}
  {{ $fn.Name }}(params: {{ $fn.Params }}): {{ $fn.Return }};
{{ end }}
}


{{ range $ifc := .extension_schema.Interfaces }}

export interface {{ $ifc.Name }} {

{{ range $fn := $ifc.Functions }}

  {{ $fn.Name }}(params: {{ $fn.Params }}): {{ $fn.Return }};

{{ end }}

}

{{ end }}
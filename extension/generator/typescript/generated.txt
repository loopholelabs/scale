// Code generated by scale-signature 0.4.7, DO NOT EDIT.
// output: types

import { Encoder, Decoder, Kind } from "@loopholelabs/polyglot"

export class HttpConfig {
  timeout: number;

  /**
  * @throws {Error}
  */
  constructor (decoder?: Decoder) {
    if (decoder) {
      let err: Error | undefined;
      try {
        err = decoder.error();
      } catch (_) {}
      if (typeof err !== "undefined") {
        throw err;
      }
      this.timeout = decoder.int32();
    } else {
      this.timeout = 60;
    }
  }

  /**
  * @throws {Error}
  */
  encode (encoder: Encoder) {
    encoder.int32(this.timeout);
  }

  /**
  * @throws {Error}
  */
  static decode (decoder: Decoder): HttpConfig | undefined {
    if (decoder.null()) {
      return undefined
    }
    return new HttpConfig(decoder);
  }

  /**
  * @throws {Error}
  */
  static encode_undefined (encoder: Encoder) {
    encoder.null();
  }
}

export class HttpResponse {
  headers: Map<string, StringList>;

  statusCode: number;

  body: Uint8Array;

  /**
  * @throws {Error}
  */
  constructor (decoder?: Decoder) {
    if (decoder) {
      let err: Error | undefined;
      try {
        err = decoder.error();
      } catch (_) {}
      if (typeof err !== "undefined") {
        throw err;
      }
      this.headers = new Map<string, StringList>();
      let headersSize = decoder.map(Kind.String, Kind.Any);
      for (let i = 0; i < headersSize; i++) {
        let key = decoder.string();
        let val = StringList.decode(decoder);
        if (typeof val !== "undefined") {
          this.headers.set(key, val);
        }
      }
      this.statusCode = decoder.int32();
      this.body = decoder.uint8Array();
    } else {
      this.headers = new Map<string, StringList>();
      this.statusCode = 0;
      this.body = new Uint8Array(0);
    }
  }

  /**
  * @throws {Error}
  */
  encode (encoder: Encoder) {
    encoder.map(this.headers.size, Kind.String, Kind.Any);
    this.headers.forEach((val, key) => {
      encoder.string(key);
      val.encode(encoder);
    });
    encoder.int32(this.statusCode);
    encoder.uint8Array(this.body);
  }

  /**
  * @throws {Error}
  */
  static decode (decoder: Decoder): HttpResponse | undefined {
    if (decoder.null()) {
      return undefined
    }
    return new HttpResponse(decoder);
  }

  /**
  * @throws {Error}
  */
  static encode_undefined (encoder: Encoder) {
    encoder.null();
  }
}

export class StringList {
  values: string[];

  /**
  * @throws {Error}
  */
  constructor (decoder?: Decoder) {
    if (decoder) {
      let err: Error | undefined;
      try {
        err = decoder.error();
      } catch (_) {}
      if (typeof err !== "undefined") {
        throw err;
      }
      const valuesSize = decoder.array(Kind.String);
      this.values = new Array(valuesSize);
      for (let i = 0; i < valuesSize; i += 1) {
        this.values[i] = decoder.string();
      }
    } else {
      this.values = [];
    }
  }

  /**
  * @throws {Error}
  */
  encode (encoder: Encoder) {
    const valuesLength = this.values.length;
    encoder.array(valuesLength, Kind.String);
    for (let i = 0; i < valuesLength; i += 1) {
      encoder.string(this.values[i]);
    }
  }

  /**
  * @throws {Error}
  */
  static decode (decoder: Decoder): StringList | undefined {
    if (decoder.null()) {
      return undefined
    }
    return new StringList(decoder);
  }

  /**
  * @throws {Error}
  */
  static encode_undefined (encoder: Encoder) {
    encoder.null();
  }
}

export class ConnectionDetails {
  url: string;

  /**
  * @throws {Error}
  */
  constructor (decoder?: Decoder) {
    if (decoder) {
      let err: Error | undefined;
      try {
        err = decoder.error();
      } catch (_) {}
      if (typeof err !== "undefined") {
        throw err;
      }
      this.url = decoder.string();
    } else {
      this.url = "https://google.com";
    }
  }

  /**
  * @throws {Error}
  */
  encode (encoder: Encoder) {
    encoder.string(this.url);
  }

  /**
  * @throws {Error}
  */
  static decode (decoder: Decoder): ConnectionDetails | undefined {
    if (decoder.null()) {
      return undefined
    }
    return new ConnectionDetails(decoder);
  }

  /**
  * @throws {Error}
  */
  static encode_undefined (encoder: Encoder) {
    encoder.null();
  }
}


// Code generated by scale-extension {{ .generator_version }}, DO NOT EDIT.
// output: {{ .package_name }}

package {{ .package_name }}

import (
	"errors"
	"sync/atomic"
	"sync"

    "github.com/loopholelabs/polyglot"
    extension "github.com/loopholelabs/scale-extension-interfaces"
)

{{ $schema := .extension_schema }}
{{ $hash := .extension_hash }}

// Write an error to the scale function guest buffer.
func hostError(mem extension.ModuleMemory, resize extension.Resizer, err error) {
	b := polyglot.NewBuffer()
	polyglot.Encoder(b).Error(err)

	writeBuffer, err := resize("ext_{{ $hash }}_Resize", uint64(b.Len()))

	if err != nil {
		panic(err)
	}

	if !mem.Write(uint32(writeBuffer), b.Bytes()) {
		panic(err)
	}
}

type hostExt struct {
  functions map[string]extension.InstallableFunc
  host *Host
}

func (he *hostExt) Init() map[string]extension.InstallableFunc {
  return he.functions
}

func (he *hostExt) Reset() {
  // Reset any instances that have been created.
  {{ range $ifc := .extension_schema.Interfaces }}
    he.host.instances_{{ $ifc.Name }} = make(map[uint64]{{ $ifc.Name }})
  {{ end }}
}

func New(impl Interface) extension.Extension {
  hostWrapper := &Host{ impl: impl }

  fns := make(map[string]extension.InstallableFunc)

// Add global functions to the runtime
{{ range $fn := .extension_schema.Functions }}
  fns["ext_{{ $hash }}_{{ $fn.Name }}"] = hostWrapper.host_ext_{{ $hash }}_{{ $fn.Name }}
{{ end }}

{{ range $ifc := .extension_schema.Interfaces }}
	hostWrapper.instances_{{ $ifc.Name }} = make(map[uint64]{{ $ifc.Name }})

  {{ range $fn := $ifc.Functions }}

  fns["ext_{{ $hash }}_{{ $ifc.Name }}_{{ $fn.Name }}"] = hostWrapper.host_ext_{{ $hash }}_{{ $ifc.Name }}_{{ $fn.Name }}

  {{ end }}
{{ end }}

  return &hostExt{
    functions: fns,
    host: hostWrapper,
  }
}

type Host struct {
  impl Interface
  {{ range $ifc := .extension_schema.Interfaces }}
  gid_{{ $ifc.Name }} uint64
  instancesLock_{{ $ifc.Name }} sync.Mutex
  instances_{{ $ifc.Name }} map[uint64]{{ $ifc.Name }}
  {{ end }}
}

// Global functions
{{ range $fn := .extension_schema.Functions }}

func (h *Host) host_ext_{{ $hash }}_{{ $fn.Name}}(mem extension.ModuleMemory, resize extension.Resizer, params []uint64) {

	ptr := uint32(params[1])
	length := uint32(params[2])
	data, _ := mem.Read(ptr, length)

	cd := &{{ $fn.Params }}{}
	cd, err := Decode{{ $fn.Params }}(cd, data)
	if err != nil {
		hostError(mem, resize, err)
    return
	}

  // Call the implementation
	r, err := h.impl.{{ $fn.Name }}(cd)
	if err!=nil {
		hostError(mem, resize, err)
    return
	}

{{- if (IsInterface $schema $fn.Return) }}

	id := atomic.AddUint64(&h.gid_{{ $fn.Return }}, 1)
	h.instancesLock_{{ $fn.Return }}.Lock()
	h.instances_{{ $fn.Return }}[id] = r
	h.instancesLock_{{ $fn.Return }}.Unlock()

	// Return the ID
	params[0] = id

{{ else }}

	b := polyglot.NewBuffer()
	r.Encode(b)

	writeBuffer, err := resize("ext_{{ $hash }}_Resize", uint64(b.Len()))

	if err != nil {
		hostError(mem, resize, err)
    return
	}

	if !mem.Write(uint32(writeBuffer), b.Bytes()) {
		hostError(mem, resize, err)
    return
	}

{{ end }}
}

{{ end }}


{{ range $ifc := .extension_schema.Interfaces }}

{{ range $fn := $ifc.Functions }}

func (h *Host) host_ext_{{ $hash }}_{{ $ifc.Name }}_{{ $fn.Name }}(mem extension.ModuleMemory, resize extension.Resizer, params []uint64) {
	h.instancesLock_{{ $ifc.Name }}.Lock()
  r, ok := h.instances_{{ $ifc.Name }}[params[0]]
	h.instancesLock_{{ $ifc.Name }}.Unlock()
	if !ok {
		hostError(mem, resize, errors.New("Instance ID not found!"))
    return
	}

	ptr := uint32(params[1])
	length := uint32(params[2])
	data, _ := mem.Read(ptr, length)

	cd := &{{ $fn.Params }}{}
	cd, err := Decode{{ $fn.Params }}(cd, data)
	if err != nil {
		hostError(mem, resize, err)
    return
	}

	resp, err := r.{{ $fn.Name }}(cd)
	if err != nil {
		hostError(mem, resize, err)
    return
	}


{{- if (IsInterface $schema $fn.Return) }}

	id := atomic.AddUint64(&h.gid_{{ $fn.Return }}, 1)
	h.instancesLock_{{ $fn.Return }}.Lock()
	h.instances_{{ $fn.Return }}[id] = resp
	h.instancesLock_{{ $fn.Return }}.Unlock()

	// Return the ID
	params[0] = id

{{ else }}

	b := polyglot.NewBuffer()
	resp.Encode(b)

	writeBuffer, err := resize("ext_{{ $hash }}_Resize", uint64(b.Len()))

	if err != nil {
		hostError(mem, resize, err)
    return
	}

	if !mem.Write(uint32(writeBuffer), b.Bytes()) {
		hostError(mem, resize, err)
    return
	}

{{ end }}
}

  {{ end }}
{{ end }}
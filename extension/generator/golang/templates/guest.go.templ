// Code generated by scale-extension {{ .version }}, DO NOT EDIT.
// schema: {{ .schema.Name }}:{{ .schema.Tag }}
// output: {{ .package }}

package {{ .package }}

import (
    "github.com/loopholelabs/polyglot"
    "unsafe"
)

var (
    writeBuffer = polyglot.NewBuffer()
    readBuffer  []byte
)

//export ext_{{ .schema.Name }}_Resize
//go:linkname ext_{{ .schema.Name }}_Resize
func ext_{{ .schema.Name }}_Resize(size uint32) uint32 {
	readBuffer = make([]byte, size)
  //if uint32(cap(readBuffer)) < size {
	//	readBuffer = append(make([]byte, 0, uint32(len(readBuffer))+size), readBuffer...)
	//}
	//readBuffer = readBuffer[:size]
	return uint32(uintptr(unsafe.Pointer(&readBuffer[0])))
}

{{ $schema := .schema }}

// Define any interfaces we need here...
// Also define structs we can use to hold instanceId

{{ range $ifc := .schema.Interfaces }}

// Define concrete types with a hidden instanceId

type _{{ $ifc.Name }} struct {
  instanceId uint64
}

{{ range $fn := $ifc.Functions }}
func (d *_{{ $ifc.Name }}) {{ $fn.Name }}(params *{{ $fn.Params }}) ({{ $fn.Return }}, error) {

  // First we take the params, serialize them.
  writeBuffer.Reset()
  params.Encode(writeBuffer)
  underlying := writeBuffer.Bytes()
  ptr := &underlying[0]
  unsafePtr := uintptr(unsafe.Pointer(ptr))
  off := uint32(unsafePtr)
  l := uint32(writeBuffer.Len())

  // Now make the call to the host.

  {{- if (IsInterface $schema $fn.Return) }}
    readBuffer = nil
    v := ext_{{ $schema.Name }}_{{ $ifc.Name }}_{{ $fn.Name }}(d.instanceId, off, l)
    // IF the return type is an interface return ifc, which contains hidden instanceId.

    // Handle error from host. In this case there'll be an error in the readBuffer
    if (readBuffer!=nil) {
      val, err := polyglot.GetDecoder(readBuffer).Error()
      if err!=nil {
        panic(err)
      }
      return &_{{ $fn.Return}}{}, val
    }

    ret := &_{{ $fn.Return }}{
      instanceId: v,
    }

    return ret, nil
  {{ else }}
    ext_{{ $schema.Name }}_{{ $ifc.Name }}_{{ $fn.Name }}(d.instanceId, off, l)
    // IF the return type is a model, we should read the data from the read buffer.

    ret := &{{ $fn.Return }}{}
    r, err := Decode{{ $fn.Return }}(ret, readBuffer)

    if err!=nil {
      return {{ $fn.Return }}{}, err
    }

    return *r, err
  {{ end }}
}

//export ext_{{ $schema.Name }}_{{ $ifc.Name }}_{{ $fn.Name }}
//go:linkname ext_{{ $schema.Name }}_{{ $ifc.Name }}_{{ $fn.Name }}
func ext_{{ $schema.Name }}_{{ $ifc.Name }}_{{ $fn.Name }}(instance uint64, offset uint32, length uint32) uint64

{{ end }}

{{ end }}

// Define any global functions here...

{{ range $fn := .schema.Functions }}

//export ext_{{ $schema.Name }}_{{ $fn.Name }}
//go:linkname ext_{{ $schema.Name }}_{{ $fn.Name }}
func ext_{{ $schema.Name }}_{{ $fn.Name }}(instance uint64, offset uint32, length uint32) uint64

func {{ $fn.Name }}(params *{{ $fn.Params }}) ({{ $fn.Return }}, error) {
  // First we take the params, serialize them.
  writeBuffer.Reset()
  params.Encode(writeBuffer)
  underlying := writeBuffer.Bytes()
  ptr := &underlying[0]
  unsafePtr := uintptr(unsafe.Pointer(ptr))
  off := uint32(unsafePtr)
  l := uint32(writeBuffer.Len())

  // Now make the call to the host.

  {{- if (IsInterface $schema $fn.Return) }}
    readBuffer = nil
    v := ext_{{ $schema.Name }}_{{ $fn.Name }}(0, off, l)
    // IF the return type is an interface return ifc, which contains hidden instanceId.

    // Handle error from host. In this case there'll be an error in the readBuffer
    if (readBuffer!=nil) {
      val, err := polyglot.GetDecoder(readBuffer).Error()
      if err!=nil {
        panic(err)
      }
      return nil, val
    }

    ret := &_{{ $fn.Return }}{
      instanceId: v,
    }

    return ret, nil
  {{ else }}
    ext_{{ $schema.Name }}_{{ $fn.Name }}(0, off, l)
    // IF the return type is a model, we should read the data from the read buffer.

    ret := &{{ $fn.Return }}{}
    r, err := Decode{{ $fn.Return }}(ret, readBuffer)

    if err!=nil {
      return {{ $fn.Return }}{}, err
    }

    return *r, err
  {{ end }}

}

{{ end }}

// Error serializes an error into the global writeBuffer and returns a pointer to the buffer and its size
//
// Users should not use this method.
func Error(err error) (uint32, uint32) {
    writeBuffer.Reset()
    polyglot.Encoder(writeBuffer).Error(err)
    underlying := writeBuffer.Bytes()
    ptr := &underlying[0]
    unsafePtr := uintptr(unsafe.Pointer(ptr))
    return uint32(unsafePtr), uint32(writeBuffer.Len())
}

// Code generated by scale-extension v0.1.0, DO NOT EDIT.
// schema: HttpFetch:alpha
// output: extfetch

package extfetch

import (
	"errors"
	"github.com/loopholelabs/polyglot"
	"sync"
	"sync/atomic"

	extension "github.com/loopholelabs/scale-extension-interfaces"
)

const identifier = "HttpFetch:alpha"

// Write an error to the scale function guest buffer.
func hostError(mem extension.ModuleMemory, resize extension.Resizer, err error) {
	b := polyglot.NewBuffer()
	polyglot.Encoder(b).Error(err)

	writeBuffer, err := resize("ext_HttpFetch_Resize", uint64(b.Len()))

	if err != nil {
		panic(err)
	}

	if !mem.Write(uint32(writeBuffer), b.Bytes()) {
		panic(err)
	}
}

type hostExt struct {
	functions map[string]extension.InstallableFunc
	host      *HttpFetchHost
}

func (he *hostExt) Init() map[string]extension.InstallableFunc {
	return he.functions
}

func (he *hostExt) Reset() {
	// Reset any instances that have been created.

	he.host.instances_HttpConnector = make(map[uint64]HttpConnector)

}

func New(impl HttpFetchIfc) extension.Extension {
	hostWrapper := &HttpFetchHost{impl: impl}

	fns := make(map[string]extension.InstallableFunc)

	// Add global functions to the runtime

	fns["ext_HttpFetch_New"] = hostWrapper.host_ext_HttpFetch_New

	hostWrapper.instances_HttpConnector = make(map[uint64]HttpConnector)

	fns["ext_HttpFetch_HttpConnector_Fetch"] = hostWrapper.host_ext_HttpFetch_HttpConnector_Fetch

	return &hostExt{
		functions: fns,
		host:      hostWrapper,
	}
}

type HttpFetchHost struct {
	impl HttpFetchIfc

	gid_HttpConnector           uint64
	instancesLock_HttpConnector sync.Mutex
	instances_HttpConnector     map[uint64]HttpConnector
}

// Global functions

func (h *HttpFetchHost) host_ext_HttpFetch_New(mem extension.ModuleMemory, resize extension.Resizer, params []uint64) {
	ptr := uint32(params[0])
	length := uint32(params[1])
	data, _ := mem.Read(ptr, length)

	cd := &HttpConfig{}
	cd, err := DecodeHttpConfig(cd, data)
	if err != nil {
		hostError(mem, resize, err)
	}

	// Call the implementation
	r, err := h.impl.New(cd)
	if err != nil {
		hostError(mem, resize, err)
	}

	id := atomic.AddUint64(&h.gid_HttpConnector, 1)
	h.instancesLock_HttpConnector.Lock()
	h.instances_HttpConnector[id] = r
	h.instancesLock_HttpConnector.Unlock()

	// Return the ID
	params[0] = id

}

func (h *HttpFetchHost) host_ext_HttpFetch_HttpConnector_Fetch(mem extension.ModuleMemory, resize extension.Resizer, params []uint64) {
	h.instancesLock_HttpConnector.Lock()
	r, ok := h.instances_HttpConnector[params[0]]
	h.instancesLock_HttpConnector.Unlock()
	if !ok {
		hostError(mem, resize, errors.New("Instance ID not found!"))
	}

	ptr := uint32(params[1])
	length := uint32(params[2])
	data, _ := mem.Read(ptr, length)

	cd := &ConnectionDetails{}
	cd, err := DecodeConnectionDetails(cd, data)
	if err != nil {
		hostError(mem, resize, err)
	}

	resp, err := r.Fetch(cd)
	if err != nil {
		hostError(mem, resize, err)
	}

	b := polyglot.NewBuffer()
	resp.Encode(b)

	writeBuffer, err := resize("ext_HttpFetch_Resize", uint64(b.Len()))

	if err != nil {
		hostError(mem, resize, err)
	}

	if !mem.Write(uint32(writeBuffer), b.Bytes()) {
		hostError(mem, resize, err)
	}

}

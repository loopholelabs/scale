// Code generated by scale-extension 0.4.5, DO NOT EDIT.
// output: types

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(unused_mut)]
use std::io::Cursor;
use polyglot_rs::{DecodingError, Encoder, Decoder, Kind};
use num_enum::TryFromPrimitive;
use std::convert::TryFrom;
use std::collections::HashMap;
use regex::Regex;
pub trait Encode {
    fn encode<'a>(
        a: Option<&Self>,
        b: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>>
    where
        Self: Sized;
}
trait EncodeSelf {
    fn encode_self<'a, 'b>(
        &'b self,
        b: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>>;
}
pub trait Decode {
    fn decode(
        b: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<Self>, Box<dyn std::error::Error>>
    where
        Self: Sized;
}
#[derive(Clone, Debug, PartialEq)]
pub struct HttpConfig {
    pub timeout: i32,
}
impl HttpConfig {
    pub fn new() -> Self {
        Self { timeout: 60 }
    }
}
impl Encode for HttpConfig {
    fn encode<'a>(
        a: Option<&HttpConfig>,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        a.encode_self(e)
    }
}
impl EncodeSelf for HttpConfig {
    fn encode_self<'a, 'b>(
        &'b self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        e.encode_i32(self.timeout)?;
        Ok(e)
    }
}
impl EncodeSelf for Option<&HttpConfig> {
    fn encode_self<'a, 'b>(
        &'b self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode_self(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}
impl EncodeSelf for Option<HttpConfig> {
    fn encode_self<'a, 'b>(
        &'b self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode_self(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}
impl Decode for HttpConfig {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<HttpConfig>, Box<dyn std::error::Error>> {
        if d.decode_none() {
            return Ok(None);
        }
        if let Ok(error) = d.decode_error() {
            return Err(error);
        }
        let mut x = HttpConfig::new();
        x.timeout = d.decode_i32()?;
        Ok(Some(x))
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct HttpResponse {
    pub headers: HashMap<String, StringList>,
    pub status_code: i32,
    pub body: Vec<u8>,
}
impl HttpResponse {
    pub fn new() -> Self {
        Self {
            headers: HashMap::new(),
            status_code: 0,
            body: Vec::with_capacity(0),
        }
    }
}
impl Encode for HttpResponse {
    fn encode<'a>(
        a: Option<&HttpResponse>,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        a.encode_self(e)
    }
}
impl EncodeSelf for HttpResponse {
    fn encode_self<'a, 'b>(
        &'b self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        e.encode_map(self.headers.len(), Kind::String, Kind::Any)?;
        for (k, v) in &self.headers {
            e.encode_string(&k)?;
            v.encode_self(e)?;
        }
        e.encode_i32(self.status_code)?;
        e.encode_bytes(&self.body)?;
        Ok(e)
    }
}
impl EncodeSelf for Option<&HttpResponse> {
    fn encode_self<'a, 'b>(
        &'b self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode_self(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}
impl EncodeSelf for Option<HttpResponse> {
    fn encode_self<'a, 'b>(
        &'b self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode_self(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}
impl Decode for HttpResponse {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<HttpResponse>, Box<dyn std::error::Error>> {
        if d.decode_none() {
            return Ok(None);
        }
        if let Ok(error) = d.decode_error() {
            return Err(error);
        }
        let mut x = HttpResponse::new();
        let size_headers = d.decode_map(Kind::String, Kind::Any)?;
        for _ in 0..size_headers {
            let k = d.decode_string()?;
            let v = StringList::decode(d)?.ok_or(DecodingError::InvalidMap)?;
            x.headers.insert(k, v);
        }
        x.status_code = d.decode_i32()?;
        x.body = d.decode_bytes()?;
        Ok(Some(x))
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct StringList {
    pub values: Vec<String>,
}
impl StringList {
    pub fn new() -> Self {
        Self {
            values: Vec::with_capacity(0),
        }
    }
}
impl Encode for StringList {
    fn encode<'a>(
        a: Option<&StringList>,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        a.encode_self(e)
    }
}
impl EncodeSelf for StringList {
    fn encode_self<'a, 'b>(
        &'b self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        e.encode_array(self.values.len(), Kind::String)?;
        for a in &self.values {
            e.encode_string(&a)?;
        }
        Ok(e)
    }
}
impl EncodeSelf for Option<&StringList> {
    fn encode_self<'a, 'b>(
        &'b self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode_self(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}
impl EncodeSelf for Option<StringList> {
    fn encode_self<'a, 'b>(
        &'b self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode_self(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}
impl Decode for StringList {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<StringList>, Box<dyn std::error::Error>> {
        if d.decode_none() {
            return Ok(None);
        }
        if let Ok(error) = d.decode_error() {
            return Err(error);
        }
        let mut x = StringList::new();
        let size_values = d.decode_array(Kind::String)?;
        for _ in 0..size_values {
            x.values.push(d.decode_string()?);
        }
        Ok(Some(x))
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct ConnectionDetails {
    pub url: String,
}
impl ConnectionDetails {
    pub fn new() -> Self {
        Self {
            url: "https://google.com".to_string(),
        }
    }
}
impl Encode for ConnectionDetails {
    fn encode<'a>(
        a: Option<&ConnectionDetails>,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        a.encode_self(e)
    }
}
impl EncodeSelf for ConnectionDetails {
    fn encode_self<'a, 'b>(
        &'b self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        e.encode_string(&self.url)?;
        Ok(e)
    }
}
impl EncodeSelf for Option<&ConnectionDetails> {
    fn encode_self<'a, 'b>(
        &'b self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode_self(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}
impl EncodeSelf for Option<ConnectionDetails> {
    fn encode_self<'a, 'b>(
        &'b self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode_self(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}
impl Decode for ConnectionDetails {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<ConnectionDetails>, Box<dyn std::error::Error>> {
        if d.decode_none() {
            return Ok(None);
        }
        if let Ok(error) = d.decode_error() {
            return Err(error);
        }
        let mut x = ConnectionDetails::new();
        x.url = d.decode_string()?;
        Ok(Some(x))
    }
}

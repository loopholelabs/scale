// Code generated by scale-extension 0.4.1, DO NOT EDIT.
// output: guest




pub mod types;
use crate::types::{Encode, Decode};

use std::io::Cursor;
use polyglot_rs::{Encoder};

static HASH: &'static str = "3914ee157703d809e20bf4e9f4a6d0cf0db287ec4b3dcfe4982c25b0101bc156";

static mut READ_BUFFER: Vec<u8> = Vec::new();
static mut WRITE_BUFFER: Vec<u8> = Vec::new();

// Interfaces



// Interface for HttpConnector

pub trait HttpConnector {


  fn Fetch(&self, ConnectionDetails) -> Result<Option<types::HttpResponse>, Box<dyn std::error::Error>>



}



// resize resizes the extensions READ_BUFFER to the given size and returns the pointer to the buffer
//
// Users should not use this method.
#[export_name = "ext_HttpFetch_Resize"]
#[no_mangle]
pub unsafe fn ext_HttpFetch_Resize(size: u32) -> *const u8 {
    READ_BUFFER.resize(size as usize, 0);
    return READ_BUFFER.as_ptr();
}

// Define any interfaces we need here...
// Also define structs we can use to hold instanceId



// Define concrete types with a hidden instanceId HttpConnector

#[derive(Clone, Debug, PartialEq)]
pub struct _HttpConnector {
    pub instanceId: u64,
}


// func (d *_HttpConnector) Fetch(params *ConnectionDetails) (HttpResponse, error) {
// }

//export ext_HttpFetch_HttpConnector_Fetch
//go:linkname ext_HttpFetch_HttpConnector_Fetch
//func ext_HttpFetch_HttpConnector_Fetch(instance uint64, offset uint32, length uint32) uint64





// Define any global functions here...



#[link(wasm_import_module = "env")]
extern "C" {
    #[link_name = "ext_HttpFetch_New"]
    fn _ext_HttpFetch_New(instance: u64, ptr: u32, size: u32) -> u64;
}
pub fn New(params: types::HttpConfig) -> Result<Option<impl types::HttpConnector>, Box<dyn std::error::Error>> {

  // TODO: First we take the params, serialize them.
  //writeBuffer.Reset()
  //params.Encode(writeBuffer)
  //underlying := writeBuffer.Bytes()
  //ptr := &underlying[0]
  //unsafePtr := uintptr(unsafe.Pointer(ptr))
  //off := uint32(unsafePtr)
  //l := uint32(writeBuffer.Len())

  // Now make the call to the host.

  let off = WRITE_BUFFER.as_ptr() as u32;
  let l = WRITE_BUFFER.len() as u32;
    let v = _ext_HttpFetch_New(0, off, l);
    // IF the return type is an interface return ifc, which contains hidden instanceId.

    // TODO: Handle error from host. In this case there'll be an error in the readBuffer

    let c = _HttpConnector{
      instanceId: v,
    };

    return Ok(Some(c));
  
}



// error serializes an error into the global WRITE_BUFFER and returns a pointer to the buffer and its size
//
// Users should not use this method.
pub unsafe fn error(error: Box<dyn std::error::Error>) -> (u32, u32) {
    let mut cursor = Cursor::new(Vec::new());
    return match cursor.encode_error(error) {
        Ok(_) => {
            let vec = cursor.into_inner();

            WRITE_BUFFER.resize(vec.len() as usize, 0);
            WRITE_BUFFER.copy_from_slice(&vec);

            (WRITE_BUFFER.as_ptr() as u32, WRITE_BUFFER.len() as u32)
        }
        Err(_) => {
            (0, 0)
        }
    };
}

// Code generated by scale-extension 0.4.5, DO NOT EDIT.
// output: guest

pub mod types;
use crate::types::{Encode, Decode};
use std::io::Cursor;
use polyglot_rs::{Decoder, Encoder};
static HASH: &'static str = "0673aeaed6f027b5bc7b4a79de1b4be4bc096366c1e406bf44face690c217cbe";
static mut READ_BUFFER: Vec<u8> = Vec::new();
static mut WRITE_BUFFER: Vec<u8> = Vec::new();
pub trait HttpConnector {
    fn Fetch(
        &self,
        params: types::ConnectionDetails,
    ) -> Result<Option<types::HttpResponse>, Box<dyn std::error::Error>>;
}
#[export_name = "ext_0673aeaed6f027b5bc7b4a79de1b4be4bc096366c1e406bf44face690c217cbe_Resize"]
#[no_mangle]
pub unsafe fn ext_0673aeaed6f027b5bc7b4a79de1b4be4bc096366c1e406bf44face690c217cbe_Resize(
    size: u32,
) -> *const u8 {
    READ_BUFFER.resize(size as usize, 0);
    return READ_BUFFER.as_ptr();
}
#[link(wasm_import_module = "env")]
extern "C" {
    #[link_name = "ext_0673aeaed6f027b5bc7b4a79de1b4be4bc096366c1e406bf44face690c217cbe_HttpConnector_Fetch"]
    fn _ext_0673aeaed6f027b5bc7b4a79de1b4be4bc096366c1e406bf44face690c217cbe_HttpConnector_Fetch(
        instance: u64,
        ptr: u32,
        size: u32,
    ) -> u64;
}
#[derive(Clone, Debug, PartialEq)]
pub struct _HttpConnector {
    pub instanceId: u64,
}
impl HttpConnector for _HttpConnector {
    fn Fetch(
        &self,
        params: types::ConnectionDetails,
    ) -> Result<Option<types::HttpResponse>, Box<dyn std::error::Error>> {
        unsafe {
            let mut cursor = Cursor::new(Vec::new());
            types::ConnectionDetails::encode(Some(&params), &mut cursor);
            let vec = cursor.into_inner();
            WRITE_BUFFER.resize(vec.len() as usize, 0);
            WRITE_BUFFER.copy_from_slice(&vec);
            let mut off = WRITE_BUFFER.as_ptr() as u32;
            let mut l = WRITE_BUFFER.len() as u32;
            _ext_0673aeaed6f027b5bc7b4a79de1b4be4bc096366c1e406bf44face690c217cbe_HttpConnector_Fetch(
                self.instanceId,
                off,
                l,
            );
            let mut cursor = Cursor::new(&mut READ_BUFFER);
            return types::HttpResponse::decode(&mut cursor);
        }
    }
}
#[link(wasm_import_module = "env")]
extern "C" {
    #[link_name = "ext_0673aeaed6f027b5bc7b4a79de1b4be4bc096366c1e406bf44face690c217cbe_New"]
    fn _ext_0673aeaed6f027b5bc7b4a79de1b4be4bc096366c1e406bf44face690c217cbe_New(
        instance: u64,
        ptr: u32,
        size: u32,
    ) -> u64;
}
pub fn New(
    params: types::HttpConfig,
) -> Result<Option<impl HttpConnector>, Box<dyn std::error::Error>> {
    unsafe {
        let mut cursor = Cursor::new(Vec::new());
        types::HttpConfig::encode(Some(&params), &mut cursor);
        let vec = cursor.into_inner();
        WRITE_BUFFER.resize(vec.len() as usize, 0);
        WRITE_BUFFER.copy_from_slice(&vec);
        let mut off = WRITE_BUFFER.as_ptr() as u32;
        let mut l = WRITE_BUFFER.len() as u32;
        READ_BUFFER.resize(0, 0);
        let v = _ext_0673aeaed6f027b5bc7b4a79de1b4be4bc096366c1e406bf44face690c217cbe_New(
            0,
            off,
            l,
        );
        if READ_BUFFER.len() > 0 {
            let mut cursor = Cursor::new(&mut READ_BUFFER);
            if let Ok(error) = cursor.decode_error() {
                return Err(error);
            }
        }
        let c = _HttpConnector { instanceId: v };
        return Ok(Some(c));
    }
}
pub unsafe fn error(error: Box<dyn std::error::Error>) -> (u32, u32) {
    let mut cursor = Cursor::new(Vec::new());
    return match cursor.encode_error(error) {
        Ok(_) => {
            let vec = cursor.into_inner();
            WRITE_BUFFER.resize(vec.len() as usize, 0);
            WRITE_BUFFER.copy_from_slice(&vec);
            (WRITE_BUFFER.as_ptr() as u32, WRITE_BUFFER.len() as u32)
        }
        Err(_) => (0, 0),
    };
}

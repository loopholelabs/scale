// Code generated by scale-extension 0.4.2, DO NOT EDIT.
// output: guest




pub mod types;
use crate::types::{Encode, Decode};

use std::io::Cursor;
use polyglot_rs::{Decoder, Encoder};

static HASH: &'static str = "3914ee157703d809e20bf4e9f4a6d0cf0db287ec4b3dcfe4982c25b0101bc156";

static mut READ_BUFFER: Vec<u8> = Vec::new();
static mut WRITE_BUFFER: Vec<u8> = Vec::new();

// Interfaces



// Interface for HttpConnector

pub trait HttpConnector {


  fn Fetch(&self, params: types::ConnectionDetails) -> Result<Option<types::HttpResponse>, Box<dyn std::error::Error>>;



}



// resize resizes the extensions READ_BUFFER to the given size and returns the pointer to the buffer
//
// Users should not use this method.
#[export_name = "ext_HttpFetch_Resize"]
#[no_mangle]
pub unsafe fn ext_HttpFetch_Resize(size: u32) -> *const u8 {
    READ_BUFFER.resize(size as usize, 0);
    return READ_BUFFER.as_ptr();
}

// Define imports for instances




#[link(wasm_import_module = "env")]
extern "C" {
    #[link_name = "ext_HttpFetch_HttpConnector_Fetch"]
    fn _ext_HttpFetch_HttpConnector_Fetch(instance: u64, ptr: u32, size: u32) -> u64;
}




// All external interface functions defined.

// Define any interfaces we need here...
// Also define structs we can use to hold instanceId




// Define concrete types with a hidden instanceId HttpConnector

#[derive(Clone, Debug, PartialEq)]
pub struct _HttpConnector {
    pub instanceId: u64,
}

impl HttpConnector for _HttpConnector {


fn Fetch(&self, params: types::ConnectionDetails) -> Result<Option<types::HttpResponse>, Box<dyn std::error::Error>> {


  unsafe {

  let mut cursor = Cursor::new(Vec::new());

  types::ConnectionDetails::encode(Some(&params), &mut cursor);

  let vec = cursor.into_inner();

  WRITE_BUFFER.resize(vec.len() as usize, 0);
  WRITE_BUFFER.copy_from_slice(&vec);

  // Now make the call to the host.

  let mut off = WRITE_BUFFER.as_ptr() as u32;
  let mut l = WRITE_BUFFER.len() as u32;
    _ext_HttpFetch_HttpConnector_Fetch(self.instanceId, off, l);
    // IF the return type is a model, we should read the data from the read buffer.

    let mut cursor = Cursor::new(&mut READ_BUFFER);
    return types::HttpResponse::decode(&mut cursor)
    
    //return Ok(Some(c))
  

  }
}



}



// Define any global functions here...



#[link(wasm_import_module = "env")]
extern "C" {
    #[link_name = "ext_HttpFetch_New"]
    fn _ext_HttpFetch_New(instance: u64, ptr: u32, size: u32) -> u64;
}
pub fn New(params: types::HttpConfig) -> Result<Option<impl HttpConnector>, Box<dyn std::error::Error>> {


  unsafe {

  let mut cursor = Cursor::new(Vec::new());

  types::HttpConfig::encode(Some(&params), &mut cursor);

  let vec = cursor.into_inner();

  WRITE_BUFFER.resize(vec.len() as usize, 0);
  WRITE_BUFFER.copy_from_slice(&vec);

  // Now make the call to the host.

  let mut off = WRITE_BUFFER.as_ptr() as u32;
  let mut l = WRITE_BUFFER.len() as u32;
    READ_BUFFER.resize(0, 0);
    let v = _ext_HttpFetch_New(0, off, l);
    // IF the return type is an interface return ifc, which contains hidden instanceId.

    // Check for an error
    if READ_BUFFER.len() > 0 {
      // Read the error and return it...
      let mut cursor = Cursor::new(&mut READ_BUFFER);
      if let Ok(error) = cursor.decode_error() {
          return Err(error);
      }
    }

    // TODO: Handle error from host. In this case there'll be an error in the readBuffer

    let c = _HttpConnector{
      instanceId: v,
    };

    return Ok(Some(c));
  
  }
}



// error serializes an error into the global WRITE_BUFFER and returns a pointer to the buffer and its size
//
// Users should not use this method.
pub unsafe fn error(error: Box<dyn std::error::Error>) -> (u32, u32) {
    let mut cursor = Cursor::new(Vec::new());
    return match cursor.encode_error(error) {
        Ok(_) => {
            let vec = cursor.into_inner();

            WRITE_BUFFER.resize(vec.len() as usize, 0);
            WRITE_BUFFER.copy_from_slice(&vec);

            (WRITE_BUFFER.as_ptr() as u32, WRITE_BUFFER.len() as u32)
        }
        Err(_) => {
            (0, 0)
        }
    };
}

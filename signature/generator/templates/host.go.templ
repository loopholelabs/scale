// Code generated by scale-signature-go {{ .version }}, DO NOT EDIT.
// schema: {{ .schema.Name }}:{{ .schema.Tag }}
// output: {{ .package }}

package {{ .package }}

import (
    "github.com/loopholelabs/scale/signature"
    "github.com/loopholelabs/polyglot"
)

const identifier = "{{ .schema.Name }}:{{ .schema.Tag }}"
const hash = "{{ .hash }}"

var _ signature.Signature = (*sig)(nil)

// sig is the host representation of the {{ .schema.Name }}:{{ .schema.Tag }} signature
//
// Users should not use this type directly, but instead pass the Signature() function
// to the Scale Runtime
type sig struct {
    ctx *Context
    buf *polyglot.Buffer
}

// Signature returns a new {{ .schema.Name }}:{{ .schema.Tag }} signature
// and tells the Scale Runtime how to use it
func Signature() signature.Signature {
    return &sig {
        buffer: polyglot.NewBuffer(),
    }
}

// Read reads the context from the given byte slice and returns an error if one occurred
//
// This method is meant to be used by the Scale Runtime to deserialize the Signature
func (x *sig) Read(b []byte) error {
    var err error
    x.ctx, err = Decode{{ .schema.Context }}(x.ctx, b)
    return err
}

// Write writes the signature into a byte slice and returns it
func (x *sig) Write() []byte {
    x.buf.Reset()
    x.ctx.Encode(x.buf)
    return x.buf.Bytes()
}

// Error writes the signature into a byte slice and returns it
func (x *sig) Error(err error) []byte {
    x.buf.Reset()
    polyglot.Encoder(x.buf).Error(err)
    return x.buf.Bytes()
}


// Identifier returns the identifier of the signature
func (x *sig) Identifier() string {
    return identifier
}

// Hash returns the hash of the signature
func (x *sig) Hash() string {
    return hash
}
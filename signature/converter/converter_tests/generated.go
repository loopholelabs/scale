// Code generated by scale-signature v0.4.5, DO NOT EDIT.
// output: generated

package generated

import (
	"errors"
	"github.com/loopholelabs/polyglot"
)

var (
	NilDecode   = errors.New("cannot decode into a nil root struct")
	InvalidEnum = errors.New("invalid enum value")
)

type GenericEnum uint32

const (
	GenericEnumFirstValue GenericEnum = 0

	GenericEnumSecondValue GenericEnum = 1

	GenericEnumDefaultValue GenericEnum = 2
)

func decodeGenericEnum(d *polyglot.Decoder) (GenericEnum, error) {
	enumValue, err := d.Uint32()
	if err != nil {
		return 0, err
	}
	switch GenericEnum(enumValue) {
	case GenericEnumFirstValue:
		return GenericEnumFirstValue, nil
	case GenericEnumSecondValue:
		return GenericEnumSecondValue, nil
	case GenericEnumDefaultValue:
		return GenericEnumDefaultValue, nil
	default:
		return 0, InvalidEnum
	}
}

type EmptyModel struct {
}

func NewEmptyModel() *EmptyModel {
	return &EmptyModel{}
}

func (x *EmptyModel) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

	}
}

func DecodeEmptyModel(x *EmptyModel, b []byte) (*EmptyModel, error) {
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return _decodeEmptyModel(x, d)
}

func _decodeEmptyModel(x *EmptyModel, d *polyglot.Decoder) (*EmptyModel, error) {
	if d.Nil() {
		return nil, nil
	}

	err, _ := d.Error()
	if err != nil {
		return nil, err
	}

	if x == nil {
		x = NewEmptyModel()
	}

	return x, nil
}

type EmbeddedModel struct {
	StringField string
}

func NewEmbeddedModel() *EmbeddedModel {
	return &EmbeddedModel{

		StringField: "DefaultValue",
	}
}

func (x *EmbeddedModel) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		e.String(x.StringField)

	}
}

func DecodeEmbeddedModel(x *EmbeddedModel, b []byte) (*EmbeddedModel, error) {
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return _decodeEmbeddedModel(x, d)
}

func _decodeEmbeddedModel(x *EmbeddedModel, d *polyglot.Decoder) (*EmbeddedModel, error) {
	if d.Nil() {
		return nil, nil
	}

	err, _ := d.Error()
	if err != nil {
		return nil, err
	}

	if x == nil {
		x = NewEmbeddedModel()
	}

	x.StringField, err = d.String()
	if err != nil {
		return nil, err
	}

	return x, nil
}

type Context struct {
	ModelField      *EmbeddedModel
	EmptyModelField *EmptyModel

	ModelArrayField      []EmbeddedModel
	EmptyModelArrayField []EmptyModel

	StringField string

	StringArrayField []string

	StringMapField map[string]string

	StringModelMapField map[string]EmbeddedModel

	Int32Field int32

	Int32ArrayField []int32

	Int32MapField map[int32]int32

	Int32MapModelField map[int32]EmbeddedModel

	Int64Field int64

	Int64ArrayField []int64

	Int64MapField map[int64]int64

	Int64MapModelField map[int64]EmbeddedModel

	Uint32Field uint32

	Uint32ArrayField []uint32

	Uint32MapField map[uint32]uint32

	Uint32MapModelField map[uint32]EmbeddedModel

	Uint64Field uint64

	Uint64ArrayField []uint64

	Uint64MapField map[uint64]uint64

	Uint64MapModelField map[uint64]EmbeddedModel

	Float32Field float32

	Float32ArrayField []float32

	Float64Field float64

	Float64ArrayField []float64

	EnumField GenericEnum

	EnumArrayField []GenericEnum

	EnumMapField map[GenericEnum]string

	EnumMapModelField map[GenericEnum]EmbeddedModel

	BytesField []byte

	BytesArrayField [][]byte

	BoolField bool

	BoolArrayField []bool
}

func NewContext() *Context {
	return &Context{

		ModelField:      NewEmbeddedModel(),
		EmptyModelField: NewEmptyModel(),

		ModelArrayField:      make([]EmbeddedModel, 0, 0),
		EmptyModelArrayField: make([]EmptyModel, 0, 0),

		StringField: "DefaultValue",

		StringArrayField: make([]string, 0, 0),

		StringMapField: make(map[string]string),

		StringModelMapField: make(map[string]EmbeddedModel),

		Int32Field: 32,

		Int32ArrayField: make([]int32, 0, 0),

		Int32MapField: make(map[int32]int32),

		Int32MapModelField: make(map[int32]EmbeddedModel),

		Int64Field: 64,

		Int64ArrayField: make([]int64, 0, 0),

		Int64MapField: make(map[int64]int64),

		Int64MapModelField: make(map[int64]EmbeddedModel),

		Uint32Field: 32,

		Uint32ArrayField: make([]uint32, 0, 0),

		Uint32MapField: make(map[uint32]uint32),

		Uint32MapModelField: make(map[uint32]EmbeddedModel),

		Uint64Field: 64,

		Uint64ArrayField: make([]uint64, 0, 0),

		Uint64MapField: make(map[uint64]uint64),

		Uint64MapModelField: make(map[uint64]EmbeddedModel),

		Float32Field: 32.32,

		Float32ArrayField: make([]float32, 0, 0),

		Float64Field: 64.64,

		Float64ArrayField: make([]float64, 0, 0),

		EnumField: GenericEnumDefaultValue,

		EnumArrayField: make([]GenericEnum, 0, 0),

		EnumMapField: make(map[GenericEnum]string),

		EnumMapModelField: make(map[GenericEnum]EmbeddedModel),

		BytesField: make([]byte, 0, 512),

		BytesArrayField: make([][]byte, 0, 0),

		BoolField: true,

		BoolArrayField: make([]bool, 0, 0),
	}
}

func (x *Context) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		x.ModelField.Encode(b)
		x.EmptyModelField.Encode(b)

		e.Slice(uint32(len(x.ModelArrayField)), polyglot.AnyKind)
		for _, a := range x.ModelArrayField {
			a.Encode(b)
		}
		e.Slice(uint32(len(x.EmptyModelArrayField)), polyglot.AnyKind)
		for _, a := range x.EmptyModelArrayField {
			a.Encode(b)
		}

		e.String(x.StringField)

		e.Slice(uint32(len(x.StringArrayField)), polyglot.StringKind)
		for _, a := range x.StringArrayField {
			e.String(a)
		}

		e.Map(uint32(len(x.StringMapField)), polyglot.StringKind, polyglot.StringKind)
		for k, v := range x.StringMapField {
			e.String(k)
			e.String(v)
		}

		e.Map(uint32(len(x.StringModelMapField)), polyglot.StringKind, polyglot.AnyKind)
		for k, v := range x.StringModelMapField {
			e.String(k)
			v.Encode(b)
		}

		e.Int32(x.Int32Field)

		e.Slice(uint32(len(x.Int32ArrayField)), polyglot.Int32Kind)
		for _, a := range x.Int32ArrayField {
			e.Int32(a)
		}

		e.Map(uint32(len(x.Int32MapField)), polyglot.Int32Kind, polyglot.Int32Kind)
		for k, v := range x.Int32MapField {
			e.Int32(k)
			e.Int32(v)
		}

		e.Map(uint32(len(x.Int32MapModelField)), polyglot.Int32Kind, polyglot.AnyKind)
		for k, v := range x.Int32MapModelField {
			e.Int32(k)
			v.Encode(b)
		}

		e.Int64(x.Int64Field)

		e.Slice(uint32(len(x.Int64ArrayField)), polyglot.Int64Kind)
		for _, a := range x.Int64ArrayField {
			e.Int64(a)
		}

		e.Map(uint32(len(x.Int64MapField)), polyglot.Int64Kind, polyglot.Int64Kind)
		for k, v := range x.Int64MapField {
			e.Int64(k)
			e.Int64(v)
		}

		e.Map(uint32(len(x.Int64MapModelField)), polyglot.Int64Kind, polyglot.AnyKind)
		for k, v := range x.Int64MapModelField {
			e.Int64(k)
			v.Encode(b)
		}

		e.Uint32(x.Uint32Field)

		e.Slice(uint32(len(x.Uint32ArrayField)), polyglot.Uint32Kind)
		for _, a := range x.Uint32ArrayField {
			e.Uint32(a)
		}

		e.Map(uint32(len(x.Uint32MapField)), polyglot.Uint32Kind, polyglot.Uint32Kind)
		for k, v := range x.Uint32MapField {
			e.Uint32(k)
			e.Uint32(v)
		}

		e.Map(uint32(len(x.Uint32MapModelField)), polyglot.Uint32Kind, polyglot.AnyKind)
		for k, v := range x.Uint32MapModelField {
			e.Uint32(k)
			v.Encode(b)
		}

		e.Uint64(x.Uint64Field)

		e.Slice(uint32(len(x.Uint64ArrayField)), polyglot.Uint64Kind)
		for _, a := range x.Uint64ArrayField {
			e.Uint64(a)
		}

		e.Map(uint32(len(x.Uint64MapField)), polyglot.Uint64Kind, polyglot.Uint64Kind)
		for k, v := range x.Uint64MapField {
			e.Uint64(k)
			e.Uint64(v)
		}

		e.Map(uint32(len(x.Uint64MapModelField)), polyglot.Uint64Kind, polyglot.AnyKind)
		for k, v := range x.Uint64MapModelField {
			e.Uint64(k)
			v.Encode(b)
		}

		e.Float32(x.Float32Field)

		e.Slice(uint32(len(x.Float32ArrayField)), polyglot.Float32Kind)
		for _, a := range x.Float32ArrayField {
			e.Float32(a)
		}

		e.Float64(x.Float64Field)

		e.Slice(uint32(len(x.Float64ArrayField)), polyglot.Float64Kind)
		for _, a := range x.Float64ArrayField {
			e.Float64(a)
		}

		e.Uint32(uint32(x.EnumField))

		e.Slice(uint32(len(x.EnumArrayField)), polyglot.Uint32Kind)
		for _, a := range x.EnumArrayField {
			e.Uint32(uint32(a))
		}

		e.Map(uint32(len(x.EnumMapField)), polyglot.Uint32Kind, polyglot.StringKind)
		for k, v := range x.EnumMapField {
			e.Uint32(uint32(k))
			e.String(v)
		}

		e.Map(uint32(len(x.EnumMapModelField)), polyglot.Uint32Kind, polyglot.AnyKind)
		for k, v := range x.EnumMapModelField {
			e.Uint32(uint32(k))
			v.Encode(b)
		}

		e.Bytes(x.BytesField)

		e.Slice(uint32(len(x.BytesArrayField)), polyglot.BytesKind)
		for _, a := range x.BytesArrayField {
			e.Bytes(a)
		}

		e.Bool(x.BoolField)

		e.Slice(uint32(len(x.BoolArrayField)), polyglot.BoolKind)
		for _, a := range x.BoolArrayField {
			e.Bool(a)
		}

	}
}

func DecodeContext(x *Context, b []byte) (*Context, error) {
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return _decodeContext(x, d)
}

func _decodeContext(x *Context, d *polyglot.Decoder) (*Context, error) {
	if d.Nil() {
		return nil, nil
	}

	err, _ := d.Error()
	if err != nil {
		return nil, err
	}

	if x == nil {
		x = NewContext()
	}

	x.ModelField, err = _decodeEmbeddedModel(nil, d)
	if err != nil {
		return nil, err
	}
	x.EmptyModelField, err = _decodeEmptyModel(nil, d)
	if err != nil {
		return nil, err
	}

	sliceSizeModelArrayField, err := d.Slice(polyglot.AnyKind)
	if err != nil {
		return nil, err
	}
	if uint32(len(x.ModelArrayField)) != sliceSizeModelArrayField {
		x.ModelArrayField = make([]EmbeddedModel, sliceSizeModelArrayField)
	}
	for i := uint32(0); i < sliceSizeModelArrayField; i++ {
		v, err := _decodeEmbeddedModel(nil, d)
		if err != nil {
			return nil, err
		}
		x.ModelArrayField[i] = *v
	}
	sliceSizeEmptyModelArrayField, err := d.Slice(polyglot.AnyKind)
	if err != nil {
		return nil, err
	}
	if uint32(len(x.EmptyModelArrayField)) != sliceSizeEmptyModelArrayField {
		x.EmptyModelArrayField = make([]EmptyModel, sliceSizeEmptyModelArrayField)
	}
	for i := uint32(0); i < sliceSizeEmptyModelArrayField; i++ {
		v, err := _decodeEmptyModel(nil, d)
		if err != nil {
			return nil, err
		}
		x.EmptyModelArrayField[i] = *v
	}

	x.StringField, err = d.String()
	if err != nil {
		return nil, err
	}

	sliceSizeStringArrayField, err := d.Slice(polyglot.StringKind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.StringArrayField)) != sliceSizeStringArrayField {
		x.StringArrayField = make([]string, sliceSizeStringArrayField)
	}

	for i := uint32(0); i < sliceSizeStringArrayField; i++ {
		x.StringArrayField[i], err = d.String()
		if err != nil {
			return nil, err
		}
	}

	mapSizeStringMapField, err := d.Map(polyglot.StringKind, polyglot.StringKind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.StringMapField)) != mapSizeStringMapField {
		x.StringMapField = make(map[string]string, mapSizeStringMapField)
	}

	for i := uint32(0); i < mapSizeStringMapField; i++ {
		k, err := d.String()
		if err != nil {
			return nil, err
		}
		x.StringMapField[k], err = d.String()
		if err != nil {
			return nil, err
		}
	}

	mapSizeStringModelMapField, err := d.Map(polyglot.StringKind, polyglot.AnyKind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.StringModelMapField)) != mapSizeStringModelMapField {
		x.StringModelMapField = make(map[string]EmbeddedModel, mapSizeStringModelMapField)
	}

	for i := uint32(0); i < mapSizeStringModelMapField; i++ {
		k, err := d.String()
		if err != nil {
			return nil, err
		}
		v, err := _decodeEmbeddedModel(nil, d)
		if err != nil {
			return nil, err
		}
		x.StringModelMapField[k] = *v
	}

	x.Int32Field, err = d.Int32()
	if err != nil {
		return nil, err
	}

	sliceSizeInt32ArrayField, err := d.Slice(polyglot.Int32Kind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Int32ArrayField)) != sliceSizeInt32ArrayField {
		x.Int32ArrayField = make([]int32, sliceSizeInt32ArrayField)
	}

	for i := uint32(0); i < sliceSizeInt32ArrayField; i++ {
		x.Int32ArrayField[i], err = d.Int32()
		if err != nil {
			return nil, err
		}
	}

	mapSizeInt32MapField, err := d.Map(polyglot.Int32Kind, polyglot.Int32Kind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Int32MapField)) != mapSizeInt32MapField {
		x.Int32MapField = make(map[int32]int32, mapSizeInt32MapField)
	}

	for i := uint32(0); i < mapSizeInt32MapField; i++ {
		k, err := d.Int32()
		if err != nil {
			return nil, err
		}
		x.Int32MapField[k], err = d.Int32()
		if err != nil {
			return nil, err
		}
	}

	mapSizeInt32MapModelField, err := d.Map(polyglot.Int32Kind, polyglot.AnyKind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Int32MapModelField)) != mapSizeInt32MapModelField {
		x.Int32MapModelField = make(map[int32]EmbeddedModel, mapSizeInt32MapModelField)
	}

	for i := uint32(0); i < mapSizeInt32MapModelField; i++ {
		k, err := d.Int32()
		if err != nil {
			return nil, err
		}
		v, err := _decodeEmbeddedModel(nil, d)
		if err != nil {
			return nil, err
		}
		x.Int32MapModelField[k] = *v
	}

	x.Int64Field, err = d.Int64()
	if err != nil {
		return nil, err
	}

	sliceSizeInt64ArrayField, err := d.Slice(polyglot.Int64Kind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Int64ArrayField)) != sliceSizeInt64ArrayField {
		x.Int64ArrayField = make([]int64, sliceSizeInt64ArrayField)
	}

	for i := uint32(0); i < sliceSizeInt64ArrayField; i++ {
		x.Int64ArrayField[i], err = d.Int64()
		if err != nil {
			return nil, err
		}
	}

	mapSizeInt64MapField, err := d.Map(polyglot.Int64Kind, polyglot.Int64Kind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Int64MapField)) != mapSizeInt64MapField {
		x.Int64MapField = make(map[int64]int64, mapSizeInt64MapField)
	}

	for i := uint32(0); i < mapSizeInt64MapField; i++ {
		k, err := d.Int64()
		if err != nil {
			return nil, err
		}
		x.Int64MapField[k], err = d.Int64()
		if err != nil {
			return nil, err
		}
	}

	mapSizeInt64MapModelField, err := d.Map(polyglot.Int64Kind, polyglot.AnyKind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Int64MapModelField)) != mapSizeInt64MapModelField {
		x.Int64MapModelField = make(map[int64]EmbeddedModel, mapSizeInt64MapModelField)
	}

	for i := uint32(0); i < mapSizeInt64MapModelField; i++ {
		k, err := d.Int64()
		if err != nil {
			return nil, err
		}
		v, err := _decodeEmbeddedModel(nil, d)
		if err != nil {
			return nil, err
		}
		x.Int64MapModelField[k] = *v
	}

	x.Uint32Field, err = d.Uint32()
	if err != nil {
		return nil, err
	}

	sliceSizeUint32ArrayField, err := d.Slice(polyglot.Uint32Kind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Uint32ArrayField)) != sliceSizeUint32ArrayField {
		x.Uint32ArrayField = make([]uint32, sliceSizeUint32ArrayField)
	}

	for i := uint32(0); i < sliceSizeUint32ArrayField; i++ {
		x.Uint32ArrayField[i], err = d.Uint32()
		if err != nil {
			return nil, err
		}
	}

	mapSizeUint32MapField, err := d.Map(polyglot.Uint32Kind, polyglot.Uint32Kind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Uint32MapField)) != mapSizeUint32MapField {
		x.Uint32MapField = make(map[uint32]uint32, mapSizeUint32MapField)
	}

	for i := uint32(0); i < mapSizeUint32MapField; i++ {
		k, err := d.Uint32()
		if err != nil {
			return nil, err
		}
		x.Uint32MapField[k], err = d.Uint32()
		if err != nil {
			return nil, err
		}
	}

	mapSizeUint32MapModelField, err := d.Map(polyglot.Uint32Kind, polyglot.AnyKind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Uint32MapModelField)) != mapSizeUint32MapModelField {
		x.Uint32MapModelField = make(map[uint32]EmbeddedModel, mapSizeUint32MapModelField)
	}

	for i := uint32(0); i < mapSizeUint32MapModelField; i++ {
		k, err := d.Uint32()
		if err != nil {
			return nil, err
		}
		v, err := _decodeEmbeddedModel(nil, d)
		if err != nil {
			return nil, err
		}
		x.Uint32MapModelField[k] = *v
	}

	x.Uint64Field, err = d.Uint64()
	if err != nil {
		return nil, err
	}

	sliceSizeUint64ArrayField, err := d.Slice(polyglot.Uint64Kind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Uint64ArrayField)) != sliceSizeUint64ArrayField {
		x.Uint64ArrayField = make([]uint64, sliceSizeUint64ArrayField)
	}

	for i := uint32(0); i < sliceSizeUint64ArrayField; i++ {
		x.Uint64ArrayField[i], err = d.Uint64()
		if err != nil {
			return nil, err
		}
	}

	mapSizeUint64MapField, err := d.Map(polyglot.Uint64Kind, polyglot.Uint64Kind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Uint64MapField)) != mapSizeUint64MapField {
		x.Uint64MapField = make(map[uint64]uint64, mapSizeUint64MapField)
	}

	for i := uint32(0); i < mapSizeUint64MapField; i++ {
		k, err := d.Uint64()
		if err != nil {
			return nil, err
		}
		x.Uint64MapField[k], err = d.Uint64()
		if err != nil {
			return nil, err
		}
	}

	mapSizeUint64MapModelField, err := d.Map(polyglot.Uint64Kind, polyglot.AnyKind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Uint64MapModelField)) != mapSizeUint64MapModelField {
		x.Uint64MapModelField = make(map[uint64]EmbeddedModel, mapSizeUint64MapModelField)
	}

	for i := uint32(0); i < mapSizeUint64MapModelField; i++ {
		k, err := d.Uint64()
		if err != nil {
			return nil, err
		}
		v, err := _decodeEmbeddedModel(nil, d)
		if err != nil {
			return nil, err
		}
		x.Uint64MapModelField[k] = *v
	}

	x.Float32Field, err = d.Float32()
	if err != nil {
		return nil, err
	}

	sliceSizeFloat32ArrayField, err := d.Slice(polyglot.Float32Kind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Float32ArrayField)) != sliceSizeFloat32ArrayField {
		x.Float32ArrayField = make([]float32, sliceSizeFloat32ArrayField)
	}

	for i := uint32(0); i < sliceSizeFloat32ArrayField; i++ {
		x.Float32ArrayField[i], err = d.Float32()
		if err != nil {
			return nil, err
		}
	}

	x.Float64Field, err = d.Float64()
	if err != nil {
		return nil, err
	}

	sliceSizeFloat64ArrayField, err := d.Slice(polyglot.Float64Kind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Float64ArrayField)) != sliceSizeFloat64ArrayField {
		x.Float64ArrayField = make([]float64, sliceSizeFloat64ArrayField)
	}

	for i := uint32(0); i < sliceSizeFloat64ArrayField; i++ {
		x.Float64ArrayField[i], err = d.Float64()
		if err != nil {
			return nil, err
		}
	}

	result, err := decodeGenericEnum(d)
	if err != nil {
		return nil, err
	}
	x.EnumField = result

	sliceSizeEnumArrayField, err := d.Slice(polyglot.Uint32Kind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.EnumArrayField)) != sliceSizeEnumArrayField {
		x.EnumArrayField = make([]GenericEnum, sliceSizeEnumArrayField)
	}

	for i := uint32(0); i < sliceSizeEnumArrayField; i++ {
		val, err := decodeGenericEnum(d)
		if err != nil {
			return nil, err
		}
		x.EnumArrayField[i] = val
	}

	mapSizeEnumMapField, err := d.Map(polyglot.Uint32Kind, polyglot.StringKind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.EnumMapField)) != mapSizeEnumMapField {
		x.EnumMapField = make(map[GenericEnum]string, mapSizeEnumMapField)
	}

	for i := uint32(0); i < mapSizeEnumMapField; i++ {
		k, err := decodeGenericEnum(d)
		if err != nil {
			return nil, err
		}
		x.EnumMapField[k], err = d.String()
		if err != nil {
			return nil, err
		}
	}

	mapSizeEnumMapModelField, err := d.Map(polyglot.Uint32Kind, polyglot.AnyKind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.EnumMapModelField)) != mapSizeEnumMapModelField {
		x.EnumMapModelField = make(map[GenericEnum]EmbeddedModel, mapSizeEnumMapModelField)
	}

	for i := uint32(0); i < mapSizeEnumMapModelField; i++ {
		k, err := decodeGenericEnum(d)
		if err != nil {
			return nil, err
		}
		v, err := _decodeEmbeddedModel(nil, d)
		if err != nil {
			return nil, err
		}
		x.EnumMapModelField[k] = *v
	}

	x.BytesField, err = d.Bytes(nil)
	if err != nil {
		return nil, err
	}

	sliceSizeBytesArrayField, err := d.Slice(polyglot.BytesKind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.BytesArrayField)) != sliceSizeBytesArrayField {
		x.BytesArrayField = make([][]byte, sliceSizeBytesArrayField)
	}

	for i := uint32(0); i < sliceSizeBytesArrayField; i++ {
		x.BytesArrayField[i], err = d.Bytes(nil)
		if err != nil {
			return nil, err
		}
	}

	x.BoolField, err = d.Bool()
	if err != nil {
		return nil, err
	}

	sliceSizeBoolArrayField, err := d.Slice(polyglot.BoolKind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.BoolArrayField)) != sliceSizeBoolArrayField {
		x.BoolArrayField = make([]bool, sliceSizeBoolArrayField)
	}

	for i := uint32(0); i < sliceSizeBoolArrayField; i++ {
		x.BoolArrayField[i], err = d.Bool()
		if err != nil {
			return nil, err
		}
	}

	return x, nil
}

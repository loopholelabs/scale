// Code generated by scale-signature-go v0.1.0, DO NOT EDIT.
// schema: MasterSchema:MasterSchemaTag
// output: golang_tests

package golang_tests

import (
	"errors"
	"fmt"
	"github.com/loopholelabs/polyglot"
	"regexp"
	"strings"
)

var (
	NilDecode   = errors.New("cannot decode into a nil root struct")
	InvalidEnum = errors.New("invalid enum value")
)

type GenericEnum uint32

const (
	GenericEnumFirstValue GenericEnum = 0

	GenericEnumSecondValue GenericEnum = 1

	GenericEnumDefaultValue GenericEnum = 2
)

func decodeGenericEnum(d *polyglot.Decoder) (GenericEnum, error) {
	enumValue, err := d.Uint32()
	if err != nil {
		return 0, err
	}
	switch GenericEnum(enumValue) {
	case GenericEnumFirstValue:
		return GenericEnumFirstValue, nil
	case GenericEnumSecondValue:
		return GenericEnumSecondValue, nil
	case GenericEnumDefaultValue:
		return GenericEnumDefaultValue, nil
	default:
		return 0, InvalidEnum
	}
}

type EmptyModel struct {
}

func NewEmptyModel() *EmptyModel {
	return &EmptyModel{}
}

func (x *EmptyModel) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

	}
}

func DecodeEmptyModel(x *EmptyModel, b []byte) (*EmptyModel, error) {
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return _decodeEmptyModel(x, d)
}

func _decodeEmptyModel(x *EmptyModel, d *polyglot.Decoder) (*EmptyModel, error) {
	if d.Nil() {
		return nil, nil
	}

	err, _ := d.Error()
	if err != nil {
		return nil, err
	}

	if x == nil {
		x = NewEmptyModel()
	}

	return x, nil
}

// EmptyModelWithDescription: Test Description
type EmptyModelWithDescription struct {
}

func NewEmptyModelWithDescription() *EmptyModelWithDescription {
	return &EmptyModelWithDescription{}
}

func (x *EmptyModelWithDescription) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

	}
}

func DecodeEmptyModelWithDescription(x *EmptyModelWithDescription, b []byte) (*EmptyModelWithDescription, error) {
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return _decodeEmptyModelWithDescription(x, d)
}

func _decodeEmptyModelWithDescription(x *EmptyModelWithDescription, d *polyglot.Decoder) (*EmptyModelWithDescription, error) {
	if d.Nil() {
		return nil, nil
	}

	err, _ := d.Error()
	if err != nil {
		return nil, err
	}

	if x == nil {
		x = NewEmptyModelWithDescription()
	}

	return x, nil
}

type ModelWithSingleStringField struct {
	StringField string
}

func NewModelWithSingleStringField() *ModelWithSingleStringField {
	return &ModelWithSingleStringField{

		StringField: "DefaultValue",
	}
}

func (x *ModelWithSingleStringField) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		e.String(x.StringField)

	}
}

func DecodeModelWithSingleStringField(x *ModelWithSingleStringField, b []byte) (*ModelWithSingleStringField, error) {
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return _decodeModelWithSingleStringField(x, d)
}

func _decodeModelWithSingleStringField(x *ModelWithSingleStringField, d *polyglot.Decoder) (*ModelWithSingleStringField, error) {
	if d.Nil() {
		return nil, nil
	}

	err, _ := d.Error()
	if err != nil {
		return nil, err
	}

	if x == nil {
		x = NewModelWithSingleStringField()
	}

	x.StringField, err = d.String()
	if err != nil {
		return nil, err
	}

	return x, nil
}

// ModelWithSingleStringFieldAndDescription: Test Description
type ModelWithSingleStringFieldAndDescription struct {
	StringField string
}

func NewModelWithSingleStringFieldAndDescription() *ModelWithSingleStringFieldAndDescription {
	return &ModelWithSingleStringFieldAndDescription{

		StringField: "DefaultValue",
	}
}

func (x *ModelWithSingleStringFieldAndDescription) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		e.String(x.StringField)

	}
}

func DecodeModelWithSingleStringFieldAndDescription(x *ModelWithSingleStringFieldAndDescription, b []byte) (*ModelWithSingleStringFieldAndDescription, error) {
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return _decodeModelWithSingleStringFieldAndDescription(x, d)
}

func _decodeModelWithSingleStringFieldAndDescription(x *ModelWithSingleStringFieldAndDescription, d *polyglot.Decoder) (*ModelWithSingleStringFieldAndDescription, error) {
	if d.Nil() {
		return nil, nil
	}

	err, _ := d.Error()
	if err != nil {
		return nil, err
	}

	if x == nil {
		x = NewModelWithSingleStringFieldAndDescription()
	}

	x.StringField, err = d.String()
	if err != nil {
		return nil, err
	}

	return x, nil
}

type ModelWithSingleInt32Field struct {
	Int32Field int32
}

func NewModelWithSingleInt32Field() *ModelWithSingleInt32Field {
	return &ModelWithSingleInt32Field{

		Int32Field: 32,
	}
}

func (x *ModelWithSingleInt32Field) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		e.Int32(x.Int32Field)

	}
}

func DecodeModelWithSingleInt32Field(x *ModelWithSingleInt32Field, b []byte) (*ModelWithSingleInt32Field, error) {
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return _decodeModelWithSingleInt32Field(x, d)
}

func _decodeModelWithSingleInt32Field(x *ModelWithSingleInt32Field, d *polyglot.Decoder) (*ModelWithSingleInt32Field, error) {
	if d.Nil() {
		return nil, nil
	}

	err, _ := d.Error()
	if err != nil {
		return nil, err
	}

	if x == nil {
		x = NewModelWithSingleInt32Field()
	}

	x.Int32Field, err = d.Int32()
	if err != nil {
		return nil, err
	}

	return x, nil
}

// ModelWithSingleInt32FieldAndDescription: Test Description
type ModelWithSingleInt32FieldAndDescription struct {
	Int32Field int32
}

func NewModelWithSingleInt32FieldAndDescription() *ModelWithSingleInt32FieldAndDescription {
	return &ModelWithSingleInt32FieldAndDescription{

		Int32Field: 32,
	}
}

func (x *ModelWithSingleInt32FieldAndDescription) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		e.Int32(x.Int32Field)

	}
}

func DecodeModelWithSingleInt32FieldAndDescription(x *ModelWithSingleInt32FieldAndDescription, b []byte) (*ModelWithSingleInt32FieldAndDescription, error) {
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return _decodeModelWithSingleInt32FieldAndDescription(x, d)
}

func _decodeModelWithSingleInt32FieldAndDescription(x *ModelWithSingleInt32FieldAndDescription, d *polyglot.Decoder) (*ModelWithSingleInt32FieldAndDescription, error) {
	if d.Nil() {
		return nil, nil
	}

	err, _ := d.Error()
	if err != nil {
		return nil, err
	}

	if x == nil {
		x = NewModelWithSingleInt32FieldAndDescription()
	}

	x.Int32Field, err = d.Int32()
	if err != nil {
		return nil, err
	}

	return x, nil
}

type ModelWithMultipleFields struct {
	StringField string

	Int32Field int32
}

func NewModelWithMultipleFields() *ModelWithMultipleFields {
	return &ModelWithMultipleFields{

		StringField: "DefaultValue",

		Int32Field: 32,
	}
}

func (x *ModelWithMultipleFields) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		e.String(x.StringField)

		e.Int32(x.Int32Field)

	}
}

func DecodeModelWithMultipleFields(x *ModelWithMultipleFields, b []byte) (*ModelWithMultipleFields, error) {
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return _decodeModelWithMultipleFields(x, d)
}

func _decodeModelWithMultipleFields(x *ModelWithMultipleFields, d *polyglot.Decoder) (*ModelWithMultipleFields, error) {
	if d.Nil() {
		return nil, nil
	}

	err, _ := d.Error()
	if err != nil {
		return nil, err
	}

	if x == nil {
		x = NewModelWithMultipleFields()
	}

	x.StringField, err = d.String()
	if err != nil {
		return nil, err
	}

	x.Int32Field, err = d.Int32()
	if err != nil {
		return nil, err
	}

	return x, nil
}

// ModelWithMultipleFieldsAndDescription: Test Description
type ModelWithMultipleFieldsAndDescription struct {
	StringField string

	Int32Field int32
}

func NewModelWithMultipleFieldsAndDescription() *ModelWithMultipleFieldsAndDescription {
	return &ModelWithMultipleFieldsAndDescription{

		StringField: "DefaultValue",

		Int32Field: 32,
	}
}

func (x *ModelWithMultipleFieldsAndDescription) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		e.String(x.StringField)

		e.Int32(x.Int32Field)

	}
}

func DecodeModelWithMultipleFieldsAndDescription(x *ModelWithMultipleFieldsAndDescription, b []byte) (*ModelWithMultipleFieldsAndDescription, error) {
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return _decodeModelWithMultipleFieldsAndDescription(x, d)
}

func _decodeModelWithMultipleFieldsAndDescription(x *ModelWithMultipleFieldsAndDescription, d *polyglot.Decoder) (*ModelWithMultipleFieldsAndDescription, error) {
	if d.Nil() {
		return nil, nil
	}

	err, _ := d.Error()
	if err != nil {
		return nil, err
	}

	if x == nil {
		x = NewModelWithMultipleFieldsAndDescription()
	}

	x.StringField, err = d.String()
	if err != nil {
		return nil, err
	}

	x.Int32Field, err = d.Int32()
	if err != nil {
		return nil, err
	}

	return x, nil
}

type ModelWithEnum struct {
	EnumField GenericEnum
}

func NewModelWithEnum() *ModelWithEnum {
	return &ModelWithEnum{

		EnumField: GenericEnumDefaultValue,
	}
}

func (x *ModelWithEnum) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		e.Uint32(uint32(x.EnumField))

	}
}

func DecodeModelWithEnum(x *ModelWithEnum, b []byte) (*ModelWithEnum, error) {
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return _decodeModelWithEnum(x, d)
}

func _decodeModelWithEnum(x *ModelWithEnum, d *polyglot.Decoder) (*ModelWithEnum, error) {
	if d.Nil() {
		return nil, nil
	}

	err, _ := d.Error()
	if err != nil {
		return nil, err
	}

	if x == nil {
		x = NewModelWithEnum()
	}

	result, err := decodeGenericEnum(d)
	if err != nil {
		return nil, err
	}
	x.EnumField = result

	return x, nil
}

// ModelWithEnumAndDescription: Test Description
type ModelWithEnumAndDescription struct {
	EnumField GenericEnum
}

func NewModelWithEnumAndDescription() *ModelWithEnumAndDescription {
	return &ModelWithEnumAndDescription{

		EnumField: GenericEnumDefaultValue,
	}
}

func (x *ModelWithEnumAndDescription) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		e.Uint32(uint32(x.EnumField))

	}
}

func DecodeModelWithEnumAndDescription(x *ModelWithEnumAndDescription, b []byte) (*ModelWithEnumAndDescription, error) {
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return _decodeModelWithEnumAndDescription(x, d)
}

func _decodeModelWithEnumAndDescription(x *ModelWithEnumAndDescription, d *polyglot.Decoder) (*ModelWithEnumAndDescription, error) {
	if d.Nil() {
		return nil, nil
	}

	err, _ := d.Error()
	if err != nil {
		return nil, err
	}

	if x == nil {
		x = NewModelWithEnumAndDescription()
	}

	result, err := decodeGenericEnum(d)
	if err != nil {
		return nil, err
	}
	x.EnumField = result

	return x, nil
}

type ModelWithEnumAccessor struct {
	enumField GenericEnum
}

func NewModelWithEnumAccessor() *ModelWithEnumAccessor {
	return &ModelWithEnumAccessor{

		enumField: GenericEnumDefaultValue,
	}
}

func (x *ModelWithEnumAccessor) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		e.Uint32(uint32(x.enumField))

	}
}

func DecodeModelWithEnumAccessor(x *ModelWithEnumAccessor, b []byte) (*ModelWithEnumAccessor, error) {
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return _decodeModelWithEnumAccessor(x, d)
}

func _decodeModelWithEnumAccessor(x *ModelWithEnumAccessor, d *polyglot.Decoder) (*ModelWithEnumAccessor, error) {
	if d.Nil() {
		return nil, nil
	}

	err, _ := d.Error()
	if err != nil {
		return nil, err
	}

	if x == nil {
		x = NewModelWithEnumAccessor()
	}

	result, err := decodeGenericEnum(d)
	if err != nil {
		return nil, err
	}
	x.enumField = result

	return x, nil
}

func (x *ModelWithEnumAccessor) GetEnumField() (GenericEnum, error) {
	return x.enumField, nil
}

func (x *ModelWithEnumAccessor) SetEnumField(v GenericEnum) error {
	x.enumField = v
	return nil
}

// ModelWithEnumAccessorAndDescription: Test Description
type ModelWithEnumAccessorAndDescription struct {
	enumField GenericEnum
}

func NewModelWithEnumAccessorAndDescription() *ModelWithEnumAccessorAndDescription {
	return &ModelWithEnumAccessorAndDescription{

		enumField: GenericEnumDefaultValue,
	}
}

func (x *ModelWithEnumAccessorAndDescription) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		e.Uint32(uint32(x.enumField))

	}
}

func DecodeModelWithEnumAccessorAndDescription(x *ModelWithEnumAccessorAndDescription, b []byte) (*ModelWithEnumAccessorAndDescription, error) {
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return _decodeModelWithEnumAccessorAndDescription(x, d)
}

func _decodeModelWithEnumAccessorAndDescription(x *ModelWithEnumAccessorAndDescription, d *polyglot.Decoder) (*ModelWithEnumAccessorAndDescription, error) {
	if d.Nil() {
		return nil, nil
	}

	err, _ := d.Error()
	if err != nil {
		return nil, err
	}

	if x == nil {
		x = NewModelWithEnumAccessorAndDescription()
	}

	result, err := decodeGenericEnum(d)
	if err != nil {
		return nil, err
	}
	x.enumField = result

	return x, nil
}

func (x *ModelWithEnumAccessorAndDescription) GetEnumField() (GenericEnum, error) {
	return x.enumField, nil
}

func (x *ModelWithEnumAccessorAndDescription) SetEnumField(v GenericEnum) error {
	x.enumField = v
	return nil
}

type ModelWithMultipleFieldsAccessor struct {
	stringField string

	int32Field int32
}

func NewModelWithMultipleFieldsAccessor() *ModelWithMultipleFieldsAccessor {
	return &ModelWithMultipleFieldsAccessor{

		stringField: "DefaultValue",

		int32Field: 32,
	}
}

func (x *ModelWithMultipleFieldsAccessor) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		e.String(x.stringField)

		e.Int32(x.int32Field)

	}
}

func DecodeModelWithMultipleFieldsAccessor(x *ModelWithMultipleFieldsAccessor, b []byte) (*ModelWithMultipleFieldsAccessor, error) {
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return _decodeModelWithMultipleFieldsAccessor(x, d)
}

func _decodeModelWithMultipleFieldsAccessor(x *ModelWithMultipleFieldsAccessor, d *polyglot.Decoder) (*ModelWithMultipleFieldsAccessor, error) {
	if d.Nil() {
		return nil, nil
	}

	err, _ := d.Error()
	if err != nil {
		return nil, err
	}

	if x == nil {
		x = NewModelWithMultipleFieldsAccessor()
	}

	x.stringField, err = d.String()
	if err != nil {
		return nil, err
	}

	x.int32Field, err = d.Int32()
	if err != nil {
		return nil, err
	}

	return x, nil
}

func (x *ModelWithMultipleFieldsAccessor) GetStringField() (string, error) {
	return x.stringField, nil
}

func (x *ModelWithMultipleFieldsAccessor) SetStringField(v string) error {
	if matched, err := regexp.MatchString(`^[a-zA-Z0-9]*$`, v); err != nil || !matched {
		return fmt.Errorf("value must match ^[a-zA-Z0-9]*$")
	}

	if len(v) > 20 || len(v) < 1 {
		return fmt.Errorf("length must be between 1 and 20")
	}

	v = strings.ToUpper(v)

	x.stringField = v
	return nil
}

func (x *ModelWithMultipleFieldsAccessor) GetInt32Field() (int32, error) {
	return x.int32Field, nil
}

func (x *ModelWithMultipleFieldsAccessor) SetInt32Field(v int32) error {
	if v > 100 || v < 0 {
		return fmt.Errorf("value must be between 0 and 100")
	}

	x.int32Field = v
	return nil
}

// ModelWithMultipleFieldsAccessorAndDescription: Test Description
type ModelWithMultipleFieldsAccessorAndDescription struct {
	stringField string

	int32Field int32
}

func NewModelWithMultipleFieldsAccessorAndDescription() *ModelWithMultipleFieldsAccessorAndDescription {
	return &ModelWithMultipleFieldsAccessorAndDescription{

		stringField: "DefaultValue",

		int32Field: 32,
	}
}

func (x *ModelWithMultipleFieldsAccessorAndDescription) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		e.String(x.stringField)

		e.Int32(x.int32Field)

	}
}

func DecodeModelWithMultipleFieldsAccessorAndDescription(x *ModelWithMultipleFieldsAccessorAndDescription, b []byte) (*ModelWithMultipleFieldsAccessorAndDescription, error) {
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return _decodeModelWithMultipleFieldsAccessorAndDescription(x, d)
}

func _decodeModelWithMultipleFieldsAccessorAndDescription(x *ModelWithMultipleFieldsAccessorAndDescription, d *polyglot.Decoder) (*ModelWithMultipleFieldsAccessorAndDescription, error) {
	if d.Nil() {
		return nil, nil
	}

	err, _ := d.Error()
	if err != nil {
		return nil, err
	}

	if x == nil {
		x = NewModelWithMultipleFieldsAccessorAndDescription()
	}

	x.stringField, err = d.String()
	if err != nil {
		return nil, err
	}

	x.int32Field, err = d.Int32()
	if err != nil {
		return nil, err
	}

	return x, nil
}

func (x *ModelWithMultipleFieldsAccessorAndDescription) GetStringField() (string, error) {
	return x.stringField, nil
}

func (x *ModelWithMultipleFieldsAccessorAndDescription) SetStringField(v string) error {

	x.stringField = v
	return nil
}

func (x *ModelWithMultipleFieldsAccessorAndDescription) GetInt32Field() (int32, error) {
	return x.int32Field, nil
}

func (x *ModelWithMultipleFieldsAccessorAndDescription) SetInt32Field(v int32) error {

	x.int32Field = v
	return nil
}

type ModelWithEmbeddedModels struct {
	EmbeddedEmptyModel *EmptyModel

	EmbeddedModelArrayWithMultipleFieldsAccessor []ModelWithMultipleFieldsAccessor
}

func NewModelWithEmbeddedModels() *ModelWithEmbeddedModels {
	return &ModelWithEmbeddedModels{

		EmbeddedEmptyModel: NewEmptyModel(),

		EmbeddedModelArrayWithMultipleFieldsAccessor: make([]ModelWithMultipleFieldsAccessor, 0, 64),
	}
}

func (x *ModelWithEmbeddedModels) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		x.EmbeddedEmptyModel.Encode(b)

		e.Slice(uint32(len(x.EmbeddedModelArrayWithMultipleFieldsAccessor)), polyglot.AnyKind)
		for _, a := range x.EmbeddedModelArrayWithMultipleFieldsAccessor {
			a.Encode(b)
		}

	}
}

func DecodeModelWithEmbeddedModels(x *ModelWithEmbeddedModels, b []byte) (*ModelWithEmbeddedModels, error) {
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return _decodeModelWithEmbeddedModels(x, d)
}

func _decodeModelWithEmbeddedModels(x *ModelWithEmbeddedModels, d *polyglot.Decoder) (*ModelWithEmbeddedModels, error) {
	if d.Nil() {
		return nil, nil
	}

	err, _ := d.Error()
	if err != nil {
		return nil, err
	}

	if x == nil {
		x = NewModelWithEmbeddedModels()
	}

	x.EmbeddedEmptyModel, err = _decodeEmptyModel(nil, d)
	if err != nil {
		return nil, err
	}

	sliceSizeEmbeddedModelArrayWithMultipleFieldsAccessor, err := d.Slice(polyglot.AnyKind)
	if err != nil {
		return nil, err
	}
	if uint32(len(x.EmbeddedModelArrayWithMultipleFieldsAccessor)) != sliceSizeEmbeddedModelArrayWithMultipleFieldsAccessor {
		x.EmbeddedModelArrayWithMultipleFieldsAccessor = make([]ModelWithMultipleFieldsAccessor, sliceSizeEmbeddedModelArrayWithMultipleFieldsAccessor)
	}
	for i := uint32(0); i < sliceSizeEmbeddedModelArrayWithMultipleFieldsAccessor; i++ {
		v, err := _decodeModelWithMultipleFieldsAccessor(nil, d)
		if err != nil {
			return nil, err
		}
		x.EmbeddedModelArrayWithMultipleFieldsAccessor[i] = *v
	}

	return x, nil
}

// ModelWithEmbeddedModelsAndDescription: Test Description
type ModelWithEmbeddedModelsAndDescription struct {
	EmbeddedEmptyModel *EmptyModel

	EmbeddedModelArrayWithMultipleFieldsAccessor []ModelWithMultipleFieldsAccessor
}

func NewModelWithEmbeddedModelsAndDescription() *ModelWithEmbeddedModelsAndDescription {
	return &ModelWithEmbeddedModelsAndDescription{

		EmbeddedEmptyModel: NewEmptyModel(),

		EmbeddedModelArrayWithMultipleFieldsAccessor: make([]ModelWithMultipleFieldsAccessor, 0, 0),
	}
}

func (x *ModelWithEmbeddedModelsAndDescription) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		x.EmbeddedEmptyModel.Encode(b)

		e.Slice(uint32(len(x.EmbeddedModelArrayWithMultipleFieldsAccessor)), polyglot.AnyKind)
		for _, a := range x.EmbeddedModelArrayWithMultipleFieldsAccessor {
			a.Encode(b)
		}

	}
}

func DecodeModelWithEmbeddedModelsAndDescription(x *ModelWithEmbeddedModelsAndDescription, b []byte) (*ModelWithEmbeddedModelsAndDescription, error) {
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return _decodeModelWithEmbeddedModelsAndDescription(x, d)
}

func _decodeModelWithEmbeddedModelsAndDescription(x *ModelWithEmbeddedModelsAndDescription, d *polyglot.Decoder) (*ModelWithEmbeddedModelsAndDescription, error) {
	if d.Nil() {
		return nil, nil
	}

	err, _ := d.Error()
	if err != nil {
		return nil, err
	}

	if x == nil {
		x = NewModelWithEmbeddedModelsAndDescription()
	}

	x.EmbeddedEmptyModel, err = _decodeEmptyModel(nil, d)
	if err != nil {
		return nil, err
	}

	sliceSizeEmbeddedModelArrayWithMultipleFieldsAccessor, err := d.Slice(polyglot.AnyKind)
	if err != nil {
		return nil, err
	}
	if uint32(len(x.EmbeddedModelArrayWithMultipleFieldsAccessor)) != sliceSizeEmbeddedModelArrayWithMultipleFieldsAccessor {
		x.EmbeddedModelArrayWithMultipleFieldsAccessor = make([]ModelWithMultipleFieldsAccessor, sliceSizeEmbeddedModelArrayWithMultipleFieldsAccessor)
	}
	for i := uint32(0); i < sliceSizeEmbeddedModelArrayWithMultipleFieldsAccessor; i++ {
		v, err := _decodeModelWithMultipleFieldsAccessor(nil, d)
		if err != nil {
			return nil, err
		}
		x.EmbeddedModelArrayWithMultipleFieldsAccessor[i] = *v
	}

	return x, nil
}

type ModelWithEmbeddedModelsAccessor struct {
	embeddedEmptyModel *EmptyModel

	embeddedModelArrayWithMultipleFieldsAccessor []ModelWithMultipleFieldsAccessor
}

func NewModelWithEmbeddedModelsAccessor() *ModelWithEmbeddedModelsAccessor {
	return &ModelWithEmbeddedModelsAccessor{

		embeddedEmptyModel: NewEmptyModel(),

		embeddedModelArrayWithMultipleFieldsAccessor: make([]ModelWithMultipleFieldsAccessor, 0),
	}
}

func (x *ModelWithEmbeddedModelsAccessor) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		x.embeddedEmptyModel.Encode(b)

		e.Slice(uint32(len(x.embeddedModelArrayWithMultipleFieldsAccessor)), polyglot.AnyKind)
		for _, a := range x.embeddedModelArrayWithMultipleFieldsAccessor {
			a.Encode(b)
		}

	}
}

func DecodeModelWithEmbeddedModelsAccessor(x *ModelWithEmbeddedModelsAccessor, b []byte) (*ModelWithEmbeddedModelsAccessor, error) {
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return _decodeModelWithEmbeddedModelsAccessor(x, d)
}

func _decodeModelWithEmbeddedModelsAccessor(x *ModelWithEmbeddedModelsAccessor, d *polyglot.Decoder) (*ModelWithEmbeddedModelsAccessor, error) {
	if d.Nil() {
		return nil, nil
	}

	err, _ := d.Error()
	if err != nil {
		return nil, err
	}

	if x == nil {
		x = NewModelWithEmbeddedModelsAccessor()
	}

	x.embeddedEmptyModel, err = _decodeEmptyModel(nil, d)
	if err != nil {
		return nil, err
	}

	sliceSizeembeddedModelArrayWithMultipleFieldsAccessor, err := d.Slice(polyglot.AnyKind)
	if err != nil {
		return nil, err
	}
	if uint32(len(x.embeddedModelArrayWithMultipleFieldsAccessor)) != sliceSizeembeddedModelArrayWithMultipleFieldsAccessor {
		x.embeddedModelArrayWithMultipleFieldsAccessor = make([]ModelWithMultipleFieldsAccessor, sliceSizeembeddedModelArrayWithMultipleFieldsAccessor)
	}
	for i := uint32(0); i < sliceSizeembeddedModelArrayWithMultipleFieldsAccessor; i++ {
		v, err := _decodeModelWithMultipleFieldsAccessor(nil, d)
		if err != nil {
			return nil, err
		}
		x.embeddedModelArrayWithMultipleFieldsAccessor[i] = *v
	}

	return x, nil
}

func (x *ModelWithEmbeddedModelsAccessor) GetEmbeddedEmptyModel() (*EmptyModel, error) {
	return x.embeddedEmptyModel, nil
}

func (x *ModelWithEmbeddedModelsAccessor) SetEmbeddedEmptyModel(v *EmptyModel) error {
	x.embeddedEmptyModel = v
	return nil
}

func (x *ModelWithEmbeddedModelsAccessor) GetEmbeddedModelArrayWithMultipleFieldsAccessor() ([]ModelWithMultipleFieldsAccessor, error) {
	return x.embeddedModelArrayWithMultipleFieldsAccessor, nil
}

func (x *ModelWithEmbeddedModelsAccessor) SetEmbeddedModelArrayWithMultipleFieldsAccessor(v []ModelWithMultipleFieldsAccessor) error {
	x.embeddedModelArrayWithMultipleFieldsAccessor = v
	return nil
}

// ModelWithEmbeddedModelsAccessorAndDescription: Test Description
type ModelWithEmbeddedModelsAccessorAndDescription struct {
	embeddedEmptyModel *EmptyModel

	embeddedModelArrayWithMultipleFieldsAccessor []ModelWithMultipleFieldsAccessor
}

func NewModelWithEmbeddedModelsAccessorAndDescription() *ModelWithEmbeddedModelsAccessorAndDescription {
	return &ModelWithEmbeddedModelsAccessorAndDescription{

		embeddedEmptyModel: NewEmptyModel(),

		embeddedModelArrayWithMultipleFieldsAccessor: make([]ModelWithMultipleFieldsAccessor, 0),
	}
}

func (x *ModelWithEmbeddedModelsAccessorAndDescription) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		x.embeddedEmptyModel.Encode(b)

		e.Slice(uint32(len(x.embeddedModelArrayWithMultipleFieldsAccessor)), polyglot.AnyKind)
		for _, a := range x.embeddedModelArrayWithMultipleFieldsAccessor {
			a.Encode(b)
		}

	}
}

func DecodeModelWithEmbeddedModelsAccessorAndDescription(x *ModelWithEmbeddedModelsAccessorAndDescription, b []byte) (*ModelWithEmbeddedModelsAccessorAndDescription, error) {
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return _decodeModelWithEmbeddedModelsAccessorAndDescription(x, d)
}

func _decodeModelWithEmbeddedModelsAccessorAndDescription(x *ModelWithEmbeddedModelsAccessorAndDescription, d *polyglot.Decoder) (*ModelWithEmbeddedModelsAccessorAndDescription, error) {
	if d.Nil() {
		return nil, nil
	}

	err, _ := d.Error()
	if err != nil {
		return nil, err
	}

	if x == nil {
		x = NewModelWithEmbeddedModelsAccessorAndDescription()
	}

	x.embeddedEmptyModel, err = _decodeEmptyModel(nil, d)
	if err != nil {
		return nil, err
	}

	sliceSizeembeddedModelArrayWithMultipleFieldsAccessor, err := d.Slice(polyglot.AnyKind)
	if err != nil {
		return nil, err
	}
	if uint32(len(x.embeddedModelArrayWithMultipleFieldsAccessor)) != sliceSizeembeddedModelArrayWithMultipleFieldsAccessor {
		x.embeddedModelArrayWithMultipleFieldsAccessor = make([]ModelWithMultipleFieldsAccessor, sliceSizeembeddedModelArrayWithMultipleFieldsAccessor)
	}
	for i := uint32(0); i < sliceSizeembeddedModelArrayWithMultipleFieldsAccessor; i++ {
		v, err := _decodeModelWithMultipleFieldsAccessor(nil, d)
		if err != nil {
			return nil, err
		}
		x.embeddedModelArrayWithMultipleFieldsAccessor[i] = *v
	}

	return x, nil
}

func (x *ModelWithEmbeddedModelsAccessorAndDescription) GetEmbeddedEmptyModel() (*EmptyModel, error) {
	return x.embeddedEmptyModel, nil
}

func (x *ModelWithEmbeddedModelsAccessorAndDescription) SetEmbeddedEmptyModel(v *EmptyModel) error {
	x.embeddedEmptyModel = v
	return nil
}

func (x *ModelWithEmbeddedModelsAccessorAndDescription) GetEmbeddedModelArrayWithMultipleFieldsAccessor() ([]ModelWithMultipleFieldsAccessor, error) {
	return x.embeddedModelArrayWithMultipleFieldsAccessor, nil
}

func (x *ModelWithEmbeddedModelsAccessorAndDescription) SetEmbeddedModelArrayWithMultipleFieldsAccessor(v []ModelWithMultipleFieldsAccessor) error {
	x.embeddedModelArrayWithMultipleFieldsAccessor = v
	return nil
}

type ModelWithAllFieldTypes struct {
	ModelField *EmptyModel

	ModelArrayField []EmptyModel

	StringField string

	StringArrayField []string

	StringMapField map[string]string

	StringMapFieldEmbedded map[string]EmptyModel

	Int32Field int32

	Int32ArrayField []int32

	Int32MapField map[int32]int32

	Int32MapFieldEmbedded map[int32]EmptyModel

	Int64Field int64

	Int64ArrayField []int64

	Int64MapField map[int64]int64

	Int64MapFieldEmbedded map[int64]EmptyModel

	Uint32Field uint32

	Uint32ArrayField []uint32

	Uint32MapField map[uint32]uint32

	Uint32MapFieldEmbedded map[uint32]EmptyModel

	Uint64Field uint64

	Uint64ArrayField []uint64

	Uint64MapField map[uint64]uint64

	Uint64MapFieldEmbedded map[uint64]EmptyModel

	Float32Field float32

	Float32ArrayField []float32

	Float64Field float64

	Float64ArrayField []float64

	EnumField GenericEnum

	EnumArrayField []GenericEnum

	EnumMapField map[GenericEnum]string

	EnumMapFieldEmbedded map[GenericEnum]EmptyModel

	BytesField []byte

	BytesArrayField [][]byte

	BoolField bool

	BoolArrayField []bool
}

func NewModelWithAllFieldTypes() *ModelWithAllFieldTypes {
	return &ModelWithAllFieldTypes{

		ModelField: NewEmptyModel(),

		ModelArrayField: make([]EmptyModel, 0, 0),

		StringField: "DefaultValue",

		StringArrayField: make([]string, 0, 0),

		StringMapField: make(map[string]string),

		StringMapFieldEmbedded: make(map[string]EmptyModel),

		Int32Field: 32,

		Int32ArrayField: make([]int32, 0, 0),

		Int32MapField: make(map[int32]int32),

		Int32MapFieldEmbedded: make(map[int32]EmptyModel),

		Int64Field: 64,

		Int64ArrayField: make([]int64, 0, 0),

		Int64MapField: make(map[int64]int64),

		Int64MapFieldEmbedded: make(map[int64]EmptyModel),

		Uint32Field: 32,

		Uint32ArrayField: make([]uint32, 0, 0),

		Uint32MapField: make(map[uint32]uint32),

		Uint32MapFieldEmbedded: make(map[uint32]EmptyModel),

		Uint64Field: 64,

		Uint64ArrayField: make([]uint64, 0, 0),

		Uint64MapField: make(map[uint64]uint64),

		Uint64MapFieldEmbedded: make(map[uint64]EmptyModel),

		Float32Field: 32.32,

		Float32ArrayField: make([]float32, 0, 0),

		Float64Field: 64.64,

		Float64ArrayField: make([]float64, 0, 0),

		EnumField: GenericEnumDefaultValue,

		EnumArrayField: make([]GenericEnum, 0, 0),

		EnumMapField: make(map[GenericEnum]string),

		EnumMapFieldEmbedded: make(map[GenericEnum]EmptyModel),

		BytesField: make([]byte, 0, 512),

		BytesArrayField: make([][]byte, 0, 0),

		BoolField: true,

		BoolArrayField: make([]bool, 0, 0),
	}
}

func (x *ModelWithAllFieldTypes) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		x.ModelField.Encode(b)

		e.Slice(uint32(len(x.ModelArrayField)), polyglot.AnyKind)
		for _, a := range x.ModelArrayField {
			a.Encode(b)
		}

		e.String(x.StringField)

		e.Slice(uint32(len(x.StringArrayField)), polyglot.StringKind)
		for _, a := range x.StringArrayField {
			e.String(a)
		}

		e.Map(uint32(len(x.StringMapField)), polyglot.StringKind, polyglot.StringKind)
		for k, v := range x.StringMapField {
			e.String(k)
			e.String(v)
		}

		e.Map(uint32(len(x.StringMapFieldEmbedded)), polyglot.StringKind, polyglot.AnyKind)
		for k, v := range x.StringMapFieldEmbedded {
			e.String(k)
			v.Encode(b)
		}

		e.Int32(x.Int32Field)

		e.Slice(uint32(len(x.Int32ArrayField)), polyglot.Int32Kind)
		for _, a := range x.Int32ArrayField {
			e.Int32(a)
		}

		e.Map(uint32(len(x.Int32MapField)), polyglot.Int32Kind, polyglot.Int32Kind)
		for k, v := range x.Int32MapField {
			e.Int32(k)
			e.Int32(v)
		}

		e.Map(uint32(len(x.Int32MapFieldEmbedded)), polyglot.Int32Kind, polyglot.AnyKind)
		for k, v := range x.Int32MapFieldEmbedded {
			e.Int32(k)
			v.Encode(b)
		}

		e.Int64(x.Int64Field)

		e.Slice(uint32(len(x.Int64ArrayField)), polyglot.Int64Kind)
		for _, a := range x.Int64ArrayField {
			e.Int64(a)
		}

		e.Map(uint32(len(x.Int64MapField)), polyglot.Int64Kind, polyglot.Int64Kind)
		for k, v := range x.Int64MapField {
			e.Int64(k)
			e.Int64(v)
		}

		e.Map(uint32(len(x.Int64MapFieldEmbedded)), polyglot.Int64Kind, polyglot.AnyKind)
		for k, v := range x.Int64MapFieldEmbedded {
			e.Int64(k)
			v.Encode(b)
		}

		e.Uint32(x.Uint32Field)

		e.Slice(uint32(len(x.Uint32ArrayField)), polyglot.Uint32Kind)
		for _, a := range x.Uint32ArrayField {
			e.Uint32(a)
		}

		e.Map(uint32(len(x.Uint32MapField)), polyglot.Uint32Kind, polyglot.Uint32Kind)
		for k, v := range x.Uint32MapField {
			e.Uint32(k)
			e.Uint32(v)
		}

		e.Map(uint32(len(x.Uint32MapFieldEmbedded)), polyglot.Uint32Kind, polyglot.AnyKind)
		for k, v := range x.Uint32MapFieldEmbedded {
			e.Uint32(k)
			v.Encode(b)
		}

		e.Uint64(x.Uint64Field)

		e.Slice(uint32(len(x.Uint64ArrayField)), polyglot.Uint64Kind)
		for _, a := range x.Uint64ArrayField {
			e.Uint64(a)
		}

		e.Map(uint32(len(x.Uint64MapField)), polyglot.Uint64Kind, polyglot.Uint64Kind)
		for k, v := range x.Uint64MapField {
			e.Uint64(k)
			e.Uint64(v)
		}

		e.Map(uint32(len(x.Uint64MapFieldEmbedded)), polyglot.Uint64Kind, polyglot.AnyKind)
		for k, v := range x.Uint64MapFieldEmbedded {
			e.Uint64(k)
			v.Encode(b)
		}

		e.Float32(x.Float32Field)

		e.Slice(uint32(len(x.Float32ArrayField)), polyglot.Float32Kind)
		for _, a := range x.Float32ArrayField {
			e.Float32(a)
		}

		e.Float64(x.Float64Field)

		e.Slice(uint32(len(x.Float64ArrayField)), polyglot.Float64Kind)
		for _, a := range x.Float64ArrayField {
			e.Float64(a)
		}

		e.Uint32(uint32(x.EnumField))

		e.Slice(uint32(len(x.EnumArrayField)), polyglot.Uint32Kind)
		for _, a := range x.EnumArrayField {
			e.Uint32(uint32(a))
		}

		e.Map(uint32(len(x.EnumMapField)), polyglot.Uint32Kind, polyglot.StringKind)
		for k, v := range x.EnumMapField {
			e.Uint32(uint32(k))
			e.String(v)
		}

		e.Map(uint32(len(x.EnumMapFieldEmbedded)), polyglot.Uint32Kind, polyglot.AnyKind)
		for k, v := range x.EnumMapFieldEmbedded {
			e.Uint32(uint32(k))
			v.Encode(b)
		}

		e.Bytes(x.BytesField)

		e.Slice(uint32(len(x.BytesArrayField)), polyglot.BytesKind)
		for _, a := range x.BytesArrayField {
			e.Bytes(a)
		}

		e.Bool(x.BoolField)

		e.Slice(uint32(len(x.BoolArrayField)), polyglot.BoolKind)
		for _, a := range x.BoolArrayField {
			e.Bool(a)
		}

	}
}

func DecodeModelWithAllFieldTypes(x *ModelWithAllFieldTypes, b []byte) (*ModelWithAllFieldTypes, error) {
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return _decodeModelWithAllFieldTypes(x, d)
}

func _decodeModelWithAllFieldTypes(x *ModelWithAllFieldTypes, d *polyglot.Decoder) (*ModelWithAllFieldTypes, error) {
	if d.Nil() {
		return nil, nil
	}

	err, _ := d.Error()
	if err != nil {
		return nil, err
	}

	if x == nil {
		x = NewModelWithAllFieldTypes()
	}

	x.ModelField, err = _decodeEmptyModel(nil, d)
	if err != nil {
		return nil, err
	}

	sliceSizeModelArrayField, err := d.Slice(polyglot.AnyKind)
	if err != nil {
		return nil, err
	}
	if uint32(len(x.ModelArrayField)) != sliceSizeModelArrayField {
		x.ModelArrayField = make([]EmptyModel, sliceSizeModelArrayField)
	}
	for i := uint32(0); i < sliceSizeModelArrayField; i++ {
		v, err := _decodeEmptyModel(nil, d)
		if err != nil {
			return nil, err
		}
		x.ModelArrayField[i] = *v
	}

	x.StringField, err = d.String()
	if err != nil {
		return nil, err
	}

	sliceSizeStringArrayField, err := d.Slice(polyglot.StringKind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.StringArrayField)) != sliceSizeStringArrayField {
		x.StringArrayField = make([]string, sliceSizeStringArrayField)
	}

	for i := uint32(0); i < sliceSizeStringArrayField; i++ {
		x.StringArrayField[i], err = d.String()
		if err != nil {
			return nil, err
		}
	}

	mapSizeStringMapField, err := d.Map(polyglot.StringKind, polyglot.StringKind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.StringMapField)) != mapSizeStringMapField {
		x.StringMapField = make(map[string]string, mapSizeStringMapField)
	}

	for i := uint32(0); i < mapSizeStringMapField; i++ {
		k, err := d.String()
		if err != nil {
			return nil, err
		}
		x.StringMapField[k], err = d.String()
		if err != nil {
			return nil, err
		}
	}

	mapSizeStringMapFieldEmbedded, err := d.Map(polyglot.StringKind, polyglot.AnyKind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.StringMapFieldEmbedded)) != mapSizeStringMapFieldEmbedded {
		x.StringMapFieldEmbedded = make(map[string]EmptyModel, mapSizeStringMapFieldEmbedded)
	}

	for i := uint32(0); i < mapSizeStringMapFieldEmbedded; i++ {
		k, err := d.String()
		if err != nil {
			return nil, err
		}
		v, err := _decodeEmptyModel(nil, d)
		if err != nil {
			return nil, err
		}
		x.StringMapFieldEmbedded[k] = *v
	}

	x.Int32Field, err = d.Int32()
	if err != nil {
		return nil, err
	}

	sliceSizeInt32ArrayField, err := d.Slice(polyglot.Int32Kind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Int32ArrayField)) != sliceSizeInt32ArrayField {
		x.Int32ArrayField = make([]int32, sliceSizeInt32ArrayField)
	}

	for i := uint32(0); i < sliceSizeInt32ArrayField; i++ {
		x.Int32ArrayField[i], err = d.Int32()
		if err != nil {
			return nil, err
		}
	}

	mapSizeInt32MapField, err := d.Map(polyglot.Int32Kind, polyglot.Int32Kind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Int32MapField)) != mapSizeInt32MapField {
		x.Int32MapField = make(map[int32]int32, mapSizeInt32MapField)
	}

	for i := uint32(0); i < mapSizeInt32MapField; i++ {
		k, err := d.Int32()
		if err != nil {
			return nil, err
		}
		x.Int32MapField[k], err = d.Int32()
		if err != nil {
			return nil, err
		}
	}

	mapSizeInt32MapFieldEmbedded, err := d.Map(polyglot.Int32Kind, polyglot.AnyKind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Int32MapFieldEmbedded)) != mapSizeInt32MapFieldEmbedded {
		x.Int32MapFieldEmbedded = make(map[int32]EmptyModel, mapSizeInt32MapFieldEmbedded)
	}

	for i := uint32(0); i < mapSizeInt32MapFieldEmbedded; i++ {
		k, err := d.Int32()
		if err != nil {
			return nil, err
		}
		v, err := _decodeEmptyModel(nil, d)
		if err != nil {
			return nil, err
		}
		x.Int32MapFieldEmbedded[k] = *v
	}

	x.Int64Field, err = d.Int64()
	if err != nil {
		return nil, err
	}

	sliceSizeInt64ArrayField, err := d.Slice(polyglot.Int64Kind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Int64ArrayField)) != sliceSizeInt64ArrayField {
		x.Int64ArrayField = make([]int64, sliceSizeInt64ArrayField)
	}

	for i := uint32(0); i < sliceSizeInt64ArrayField; i++ {
		x.Int64ArrayField[i], err = d.Int64()
		if err != nil {
			return nil, err
		}
	}

	mapSizeInt64MapField, err := d.Map(polyglot.Int64Kind, polyglot.Int64Kind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Int64MapField)) != mapSizeInt64MapField {
		x.Int64MapField = make(map[int64]int64, mapSizeInt64MapField)
	}

	for i := uint32(0); i < mapSizeInt64MapField; i++ {
		k, err := d.Int64()
		if err != nil {
			return nil, err
		}
		x.Int64MapField[k], err = d.Int64()
		if err != nil {
			return nil, err
		}
	}

	mapSizeInt64MapFieldEmbedded, err := d.Map(polyglot.Int64Kind, polyglot.AnyKind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Int64MapFieldEmbedded)) != mapSizeInt64MapFieldEmbedded {
		x.Int64MapFieldEmbedded = make(map[int64]EmptyModel, mapSizeInt64MapFieldEmbedded)
	}

	for i := uint32(0); i < mapSizeInt64MapFieldEmbedded; i++ {
		k, err := d.Int64()
		if err != nil {
			return nil, err
		}
		v, err := _decodeEmptyModel(nil, d)
		if err != nil {
			return nil, err
		}
		x.Int64MapFieldEmbedded[k] = *v
	}

	x.Uint32Field, err = d.Uint32()
	if err != nil {
		return nil, err
	}

	sliceSizeUint32ArrayField, err := d.Slice(polyglot.Uint32Kind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Uint32ArrayField)) != sliceSizeUint32ArrayField {
		x.Uint32ArrayField = make([]uint32, sliceSizeUint32ArrayField)
	}

	for i := uint32(0); i < sliceSizeUint32ArrayField; i++ {
		x.Uint32ArrayField[i], err = d.Uint32()
		if err != nil {
			return nil, err
		}
	}

	mapSizeUint32MapField, err := d.Map(polyglot.Uint32Kind, polyglot.Uint32Kind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Uint32MapField)) != mapSizeUint32MapField {
		x.Uint32MapField = make(map[uint32]uint32, mapSizeUint32MapField)
	}

	for i := uint32(0); i < mapSizeUint32MapField; i++ {
		k, err := d.Uint32()
		if err != nil {
			return nil, err
		}
		x.Uint32MapField[k], err = d.Uint32()
		if err != nil {
			return nil, err
		}
	}

	mapSizeUint32MapFieldEmbedded, err := d.Map(polyglot.Uint32Kind, polyglot.AnyKind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Uint32MapFieldEmbedded)) != mapSizeUint32MapFieldEmbedded {
		x.Uint32MapFieldEmbedded = make(map[uint32]EmptyModel, mapSizeUint32MapFieldEmbedded)
	}

	for i := uint32(0); i < mapSizeUint32MapFieldEmbedded; i++ {
		k, err := d.Uint32()
		if err != nil {
			return nil, err
		}
		v, err := _decodeEmptyModel(nil, d)
		if err != nil {
			return nil, err
		}
		x.Uint32MapFieldEmbedded[k] = *v
	}

	x.Uint64Field, err = d.Uint64()
	if err != nil {
		return nil, err
	}

	sliceSizeUint64ArrayField, err := d.Slice(polyglot.Uint64Kind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Uint64ArrayField)) != sliceSizeUint64ArrayField {
		x.Uint64ArrayField = make([]uint64, sliceSizeUint64ArrayField)
	}

	for i := uint32(0); i < sliceSizeUint64ArrayField; i++ {
		x.Uint64ArrayField[i], err = d.Uint64()
		if err != nil {
			return nil, err
		}
	}

	mapSizeUint64MapField, err := d.Map(polyglot.Uint64Kind, polyglot.Uint64Kind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Uint64MapField)) != mapSizeUint64MapField {
		x.Uint64MapField = make(map[uint64]uint64, mapSizeUint64MapField)
	}

	for i := uint32(0); i < mapSizeUint64MapField; i++ {
		k, err := d.Uint64()
		if err != nil {
			return nil, err
		}
		x.Uint64MapField[k], err = d.Uint64()
		if err != nil {
			return nil, err
		}
	}

	mapSizeUint64MapFieldEmbedded, err := d.Map(polyglot.Uint64Kind, polyglot.AnyKind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Uint64MapFieldEmbedded)) != mapSizeUint64MapFieldEmbedded {
		x.Uint64MapFieldEmbedded = make(map[uint64]EmptyModel, mapSizeUint64MapFieldEmbedded)
	}

	for i := uint32(0); i < mapSizeUint64MapFieldEmbedded; i++ {
		k, err := d.Uint64()
		if err != nil {
			return nil, err
		}
		v, err := _decodeEmptyModel(nil, d)
		if err != nil {
			return nil, err
		}
		x.Uint64MapFieldEmbedded[k] = *v
	}

	x.Float32Field, err = d.Float32()
	if err != nil {
		return nil, err
	}

	sliceSizeFloat32ArrayField, err := d.Slice(polyglot.Float32Kind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Float32ArrayField)) != sliceSizeFloat32ArrayField {
		x.Float32ArrayField = make([]float32, sliceSizeFloat32ArrayField)
	}

	for i := uint32(0); i < sliceSizeFloat32ArrayField; i++ {
		x.Float32ArrayField[i], err = d.Float32()
		if err != nil {
			return nil, err
		}
	}

	x.Float64Field, err = d.Float64()
	if err != nil {
		return nil, err
	}

	sliceSizeFloat64ArrayField, err := d.Slice(polyglot.Float64Kind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.Float64ArrayField)) != sliceSizeFloat64ArrayField {
		x.Float64ArrayField = make([]float64, sliceSizeFloat64ArrayField)
	}

	for i := uint32(0); i < sliceSizeFloat64ArrayField; i++ {
		x.Float64ArrayField[i], err = d.Float64()
		if err != nil {
			return nil, err
		}
	}

	result, err := decodeGenericEnum(d)
	if err != nil {
		return nil, err
	}
	x.EnumField = result

	sliceSizeEnumArrayField, err := d.Slice(polyglot.Uint32Kind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.EnumArrayField)) != sliceSizeEnumArrayField {
		x.EnumArrayField = make([]GenericEnum, sliceSizeEnumArrayField)
	}

	for i := uint32(0); i < sliceSizeEnumArrayField; i++ {
		val, err := decodeGenericEnum(d)
		if err != nil {
			return nil, err
		}
		x.EnumArrayField[i] = val
	}

	mapSizeEnumMapField, err := d.Map(polyglot.Uint32Kind, polyglot.StringKind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.EnumMapField)) != mapSizeEnumMapField {
		x.EnumMapField = make(map[GenericEnum]string, mapSizeEnumMapField)
	}

	for i := uint32(0); i < mapSizeEnumMapField; i++ {
		k, err := decodeGenericEnum(d)
		if err != nil {
			return nil, err
		}
		x.EnumMapField[k], err = d.String()
		if err != nil {
			return nil, err
		}
	}

	mapSizeEnumMapFieldEmbedded, err := d.Map(polyglot.Uint32Kind, polyglot.AnyKind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.EnumMapFieldEmbedded)) != mapSizeEnumMapFieldEmbedded {
		x.EnumMapFieldEmbedded = make(map[GenericEnum]EmptyModel, mapSizeEnumMapFieldEmbedded)
	}

	for i := uint32(0); i < mapSizeEnumMapFieldEmbedded; i++ {
		k, err := decodeGenericEnum(d)
		if err != nil {
			return nil, err
		}
		v, err := _decodeEmptyModel(nil, d)
		if err != nil {
			return nil, err
		}
		x.EnumMapFieldEmbedded[k] = *v
	}

	x.BytesField, err = d.Bytes(nil)
	if err != nil {
		return nil, err
	}

	sliceSizeBytesArrayField, err := d.Slice(polyglot.BytesKind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.BytesArrayField)) != sliceSizeBytesArrayField {
		x.BytesArrayField = make([][]byte, sliceSizeBytesArrayField)
	}

	for i := uint32(0); i < sliceSizeBytesArrayField; i++ {
		x.BytesArrayField[i], err = d.Bytes(nil)
		if err != nil {
			return nil, err
		}
	}

	x.BoolField, err = d.Bool()
	if err != nil {
		return nil, err
	}

	sliceSizeBoolArrayField, err := d.Slice(polyglot.BoolKind)
	if err != nil {
		return nil, err
	}

	if uint32(len(x.BoolArrayField)) != sliceSizeBoolArrayField {
		x.BoolArrayField = make([]bool, sliceSizeBoolArrayField)
	}

	for i := uint32(0); i < sliceSizeBoolArrayField; i++ {
		x.BoolArrayField[i], err = d.Bool()
		if err != nil {
			return nil, err
		}
	}

	return x, nil
}

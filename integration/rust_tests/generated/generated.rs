// Code generated by scale-signature 0.1.0, DO NOT EDIT.
// output: generated

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(unused_mut)]
use std::io::Cursor;
use polyglot_rs::{DecodingError, Encoder, Decoder, Kind};
use num_enum::TryFromPrimitive;
use std::convert::TryFrom;
use std::collections::HashMap;
use regex::Regex;
pub trait Encode {
    fn encode<'a>(
        a: Option<&Self>,
        b: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>>
    where
        Self: Sized;
}
trait EncodeSelf {
    fn encode_self<'a, 'b>(
        &'b self,
        b: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>>;
}
pub trait Decode {
    fn decode(
        b: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<Self>, Box<dyn std::error::Error>>
    where
        Self: Sized;
}
#[derive(Clone, Debug, PartialEq)]
pub struct Context {
    pub a: i32,
    pub b: i32,
    pub c: i32,
}
impl Context {
    pub fn new() -> Self {
        Self { a: 0, b: 0, c: 0 }
    }
}
impl Encode for Context {
    fn encode<'a>(
        a: Option<&Context>,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        a.encode_self(e)
    }
}
impl EncodeSelf for Context {
    fn encode_self<'a, 'b>(
        &'b self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        e.encode_i32(self.a)?;
        e.encode_i32(self.b)?;
        e.encode_i32(self.c)?;
        Ok(e)
    }
}
impl EncodeSelf for Option<&Context> {
    fn encode_self<'a, 'b>(
        &'b self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode_self(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}
impl EncodeSelf for Option<Context> {
    fn encode_self<'a, 'b>(
        &'b self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode_self(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}
impl Decode for Context {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<Context>, Box<dyn std::error::Error>> {
        if d.decode_none() {
            return Ok(None);
        }
        if let Ok(error) = d.decode_error() {
            return Err(error);
        }
        let mut x = Context::new();
        x.a = d.decode_i32()?;
        x.b = d.decode_i32()?;
        x.c = d.decode_i32()?;
        Ok(Some(x))
    }
}

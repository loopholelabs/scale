{
  "version": 3,
  "sources": ["<stdin>"],
  "sourceRoot": "index.js",
  "sourcesContent": ["// Code generated by scale-signature 0.4.1, DO NOT EDIT.\n// output: local-example-latest-host\n\n/* eslint no-bitwise: off */\n\nimport { Signature as SignatureInterface } from \"@loopholelabs/scale-signature-interfaces\";\nimport { Decoder, Encoder, Kind } from \"@loopholelabs/polyglot\";\n\nexport * from \"./types\";\nimport { ModelWithAllFieldTypes } from \"./types\";\n\nconst hash = \"3a592aa345d412faa2e6285ee048ca2ab5aa64b0caa2f9ca67b2c1e0792101e5\"\n\n// New returns a new signature and tells the Scale Runtime how to use it\n//\n// This function should be passed into the scale runtime config as an argument\nexport function New(): Signature {\n  return new Signature();\n}\n\n// Signature is the host representation of the signature\n//\n// Users should not use this type directly, but instead pass the New() function\n// to the Scale Runtime\nexport class Signature implements SignatureInterface {\n  public context: ModelWithAllFieldTypes;\n\n  constructor() {\n    this.context = new ModelWithAllFieldTypes();\n  }\n\n  // Read reads the context from the given Uint8Array and returns an error if one occurred\n  //\n  // This method is meant to be used by the Scale Runtime to deserialize the Signature\n  Read(b: Uint8Array): Error | undefined {\n    const dec = new Decoder(b);\n    try {\n      Object.assign(this.context, ModelWithAllFieldTypes.decode(dec));\n    } catch (err) {\n      return err as Error;\n    }\n    return undefined;\n  }\n\n  // Write writes the signature into a Uint8Array and returns it\n  //\n  // This method is meant to be used by the Scale Runtime to serialize the Signature\n  Write(): Uint8Array {\n    const enc = new Encoder();\n    this.context.encode(enc);\n    return enc.bytes;\n  }\n\n  // Error writes the signature into a Uint8Array and returns it\n  //\n  // This method is meant to be used by the Scale Runtime to return an error\n  Error(err: Error): Uint8Array {\n    const enc = new Encoder();\n    enc.error(err);\n    return enc.bytes;\n  }\n\n  // Hash returns the hash of the signature\n  //\n  // This method is meant to be used by the Scale Runtime to validate Signature and Function compatibility\n  Hash(): string {\n    return hash;\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,sBAAuC;AAEvC,0BAAc,oBARd;AASA,mBAAuC;AAEvC,MAAM,OAAO;AAKN,SAAS,MAAiB;AAC/B,SAAO,IAAI,UAAU;AACvB;AAMO,MAAM,UAAwC;AAAA,EAGnD,cAAc;AACZ,SAAK,UAAU,IAAI,oCAAuB;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA,EAKA,KAAK,GAAkC;AACrC,UAAM,MAAM,IAAI,wBAAQ,CAAC;AACzB,QAAI;AACF,aAAO,OAAO,KAAK,SAAS,oCAAuB,OAAO,GAAG,CAAC;AAAA,IAChE,SAAS,KAAK;AACZ,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,QAAoB;AAClB,UAAM,MAAM,IAAI,wBAAQ;AACxB,SAAK,QAAQ,OAAO,GAAG;AACvB,WAAO,IAAI;AAAA,EACb;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,KAAwB;AAC5B,UAAM,MAAM,IAAI,wBAAQ;AACxB,QAAI,MAAM,GAAG;AACb,WAAO,IAAI;AAAA,EACb;AAAA;AAAA;AAAA;AAAA,EAKA,OAAe;AACb,WAAO;AAAA,EACT;AACF;",
  "names": []
}

// Code generated by scale-signature 0.4.7, DO NOT EDIT.
// output: local_inttest_latest_guest

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(unused_mut)]
use std::io::Cursor;
use polyglot_rs::{DecodingError, Encoder, Decoder, Kind};
use num_enum::TryFromPrimitive;
use std::convert::TryFrom;
use std::collections::HashMap;
use regex::Regex;
pub trait Encode {
    fn encode<'a>(
        a: Option<&Self>,
        b: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>>
    where
        Self: Sized;
}
trait EncodeSelf {
    fn encode_self<'a, 'b>(
        &'b self,
        b: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>>;
}
pub trait Decode {
    fn decode(
        b: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<Self>, Box<dyn std::error::Error>>
    where
        Self: Sized;
}
#[derive(Clone, Debug, PartialEq)]
pub struct Stringval {
    pub value: String,
}
impl Stringval {
    pub fn new() -> Self {
        Self { value: "".to_string() }
    }
}
impl Encode for Stringval {
    fn encode<'a>(
        a: Option<&Stringval>,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        a.encode_self(e)
    }
}
impl EncodeSelf for Stringval {
    fn encode_self<'a, 'b>(
        &'b self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        e.encode_string(&self.value)?;
        Ok(e)
    }
}
impl EncodeSelf for Option<&Stringval> {
    fn encode_self<'a, 'b>(
        &'b self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode_self(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}
impl EncodeSelf for Option<Stringval> {
    fn encode_self<'a, 'b>(
        &'b self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&'a mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode_self(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}
impl Decode for Stringval {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<Stringval>, Box<dyn std::error::Error>> {
        if d.decode_none() {
            return Ok(None);
        }
        if let Ok(error) = d.decode_error() {
            return Err(error);
        }
        let mut x = Stringval::new();
        x.value = d.decode_string()?;
        Ok(Some(x))
    }
}
